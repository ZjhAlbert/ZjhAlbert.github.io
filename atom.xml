<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>VenusJ</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="/"/>
  <updated>2020-08-11T14:52:30.642Z</updated>
  <id>/</id>
  
  <author>
    <name>VenusJ</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Mybatis使用了哪些设计模式</title>
    <link href="/2020/08/11/Mybatis%E4%BD%BF%E7%94%A8%E4%BA%86%E5%93%AA%E4%BA%9B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>/2020/08/11/Mybatis使用了哪些设计模式/</id>
    <published>2020-08-10T16:00:00.000Z</published>
    <updated>2020-08-11T14:52:30.642Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Mybatis使用了哪些设计模式"><a href="#Mybatis使用了哪些设计模式" class="headerlink" title="Mybatis使用了哪些设计模式"></a>Mybatis使用了哪些设计模式</h1><ul><li>工厂模式</li></ul><p>工厂模式就是提供一个工厂类，当有客户端需要调用的时候，只调用这个工厂类就可以得到自己想要的结果，从而无需关注某类的具体实现过程。</p><p>工厂模式在MyBatis中的典型代表就是SqlSessionFactory.</p><p>SqlSession是MyBatis中的重要Java接口，可以通过该接口来执行SQL命令，获取映射器实例和管理事务，而SqlSessionFactory<br>正是用来产生SqlSession对象，所以它在MyBatis中是比较核心的接口之一。<br><a id="more"></a><br>工厂模式应用解析：<br>SqlSessionFactory是一个接口类，它的子类DefaultSqlSessionFactory有一个openSession(ExecutorType execType)方法，其中使用了<br>工厂迷失，源码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public SqlSession openSession(ExecutorType execType) &#123;</span><br><span class="line">    return this.openSessionFromDataSource(execType, (TransactionIsolationLevel)null, false);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>openSessionFromDataSource方法里：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">private SqlSession openSessionFromDataSource(ExecutorType execType, TransactionIsolationLevel level, boolean autoCommit) &#123;</span><br><span class="line">    Transaction tx = null;</span><br><span class="line"></span><br><span class="line">    DefaultSqlSession var8;</span><br><span class="line">    try &#123;</span><br><span class="line">        Environment environment = this.configuration.getEnvironment();</span><br><span class="line">        TransactionFactory transactionFactory = this.getTransactionFactoryFromEnvironment(environment);</span><br><span class="line">        tx = transactionFactory.newTransaction(environment.getDataSource(), level, autoCommit);</span><br><span class="line">        Executor executor = this.configuration.newExecutor(tx, execType);</span><br><span class="line">        var8 = new DefaultSqlSession(this.configuration, executor, autoCommit);</span><br><span class="line">    &#125; catch (Exception var12) &#123;</span><br><span class="line">        this.closeTransaction(tx);</span><br><span class="line">        throw ExceptionFactory.wrapException(&quot;Error opening session.  Cause: &quot; + var12, var12);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        ErrorContext.instance().reset();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return var8;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>configuration.newExecutor(tx, execType)这个方法读取对应的环境配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public Executor newExecutor(Transaction transaction, ExecutorType executorType) &#123;</span><br><span class="line">    executorType = executorType == null ? this.defaultExecutorType : executorType;</span><br><span class="line">    executorType = executorType == null ? ExecutorType.SIMPLE : executorType;</span><br><span class="line">    Object executor;</span><br><span class="line">    if (ExecutorType.BATCH == executorType) &#123;</span><br><span class="line">        executor = new BatchExecutor(this, transaction);</span><br><span class="line">    &#125; else if (ExecutorType.REUSE == executorType) &#123;</span><br><span class="line">        executor = new ReuseExecutor(this, transaction);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        executor = new SimpleExecutor(this, transaction);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (this.cacheEnabled) &#123;</span><br><span class="line">        executor = new CachingExecutor((Executor)executor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Executor executor = (Executor)this.interceptorChain.pluginAll(executor);</span><br><span class="line">    return executor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>从该方法我们看出newExecutor()方法为标准的工厂模式，它会根据传递executorType值生成相应的对象然后进行返回。</p><ul><li>建造者模式(Builder)</li></ul><p>建造者模式指的是将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。<br>也就是说建造者模式是通过多个模块一步步实现了对象的构建，相同的构建过程可以创建不同的产品。</p><p>建造者模式在MyBatis中的典型代表是SqlSessionFactoryBuilder.<br>普通对象都是通过new关键字直接创建的，但是如果创建对象需要的构造参数很多，且不能保证每个参数都是正确的或者<br>不能一次性得到构建所需的所有参数，name就需要将构建逻辑从对象本省抽离出来，让对象只关注功能，把构建交给构建类，<br>这样可以简化对象的构建，也可以达到分步构建对象的目的，而SqlSessionFactoryBuilder的构建过程正是如此。</p><p>在SqlSessionFactoryBuilder中构建SqlSessionFactory对象的过程是这样的，首先需要通过XMLConfigBuilder对象读取<br>并解析XML配置文件，然后再读取到配置信息存入到Configuration类中，然后再通过build方法生成我们需要的DefaultSqlSessionFactory对象，<br>实现源码如下：<br>SqlSessionFactoryBuilder.class中的build()方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public SqlSessionFactory build(InputStream inputStream, String environment, Properties properties) &#123;</span><br><span class="line">    SqlSessionFactory var5;</span><br><span class="line">    try &#123;</span><br><span class="line">        // 读取配置文件</span><br><span class="line">        XMLConfigBuilder parser = new XMLConfigBuilder(inputStream, environment, properties);</span><br><span class="line">        // 生成对象</span><br><span class="line">        var5 = this.build(parser.parse());</span><br><span class="line">    &#125; catch (Exception var14) &#123;</span><br><span class="line">        throw ExceptionFactory.wrapException(&quot;Error building SqlSession.&quot;, var14);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        ErrorContext.instance().reset();</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            inputStream.close();</span><br><span class="line">        &#125; catch (IOException var13) &#123;</span><br><span class="line">            ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return var5;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public SqlSessionFactory build(Configuration config) &#123;</span><br><span class="line">    return new DefaultSqlSessionFactory(config);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>SqlSessionFactoryBuilder类相当于一个建造过程，先读取配置文件或者配置信息、再解析配置、然后通过反射生成对象，最后再把<br>结果存入缓存，这样就一步步构建出一个SqlSessionFactory对象。</p><ul><li>单例模式</li></ul><p>单例模式在Mybatis中的典型代表是ErrorContext</p><p>ErrorContext是线程级别的单例，每个线程中有一个此对象的单例，用于记录该线程的执行环境的错误信息。</p><p>ErrorContext的实现源码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class ErrorContext &#123;</span><br><span class="line">    private static final String LINE_SEPARATOR = System.getProperty(&quot;line.separator&quot;, &quot;\n&quot;);</span><br><span class="line">    private static final ThreadLocal&lt;ErrorContext&gt; LOCAL = new ThreadLocal();</span><br><span class="line">    private ErrorContext stored;</span><br><span class="line">    private String resource;</span><br><span class="line">    private String activity;</span><br><span class="line">    private String object;</span><br><span class="line">    private String message;</span><br><span class="line">    private String sql;</span><br><span class="line">    private Throwable cause;</span><br><span class="line"></span><br><span class="line">    private ErrorContext() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static ErrorContext instance() &#123;</span><br><span class="line">        ErrorContext context = (ErrorContext)LOCAL.get();</span><br><span class="line">        if (context == null) &#123;</span><br><span class="line">            context = new ErrorContext();</span><br><span class="line">            LOCAL.set(context);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return context;</span><br><span class="line">    &#125;</span><br><span class="line">    // 部分代码省略</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>可以看出ErrorContext使用private修饰的ThreadLocal来保证每一个线程拥有一个ErrorContext对象，<br>在调用instance()方法时，再从ThreadLocal中获取此单例对象。</p><ul><li>适配器模式</li></ul><p>适配器模式是指将一个不兼容的接口转换成另一个可以兼容的接口，这样既可以使那些不兼容的类可以一起工作。</p><p>适配器模式在Mybatis中的典型代表是Log接口。</p><p>Mybatis中的日志模块适配了以下多种日志类型：</p><ul><li>SLF4J</li><li>Apache Commons Logging</li><li>Log4j2</li><li>log4j</li><li>JDK logging</li></ul><p>首先MyBatis定义了一个Log接口，用于统一和规范接口的行为，源码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public interface Log &#123;</span><br><span class="line">    boolean isDebugEnabled();</span><br><span class="line"></span><br><span class="line">    boolean isTraceEnabled();</span><br><span class="line"></span><br><span class="line">    void error(String var1, Throwable var2);</span><br><span class="line"></span><br><span class="line">    void error(String var1);</span><br><span class="line"></span><br><span class="line">    void debug(String var1);</span><br><span class="line"></span><br><span class="line">    void trace(String var1);</span><br><span class="line"></span><br><span class="line">    void warn(String var1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后Mybatis定义了多个适配接口，例如Log4j2实现源码如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">public class Log4j2Impl implements Log &#123;</span><br><span class="line">    private final Log log;</span><br><span class="line"></span><br><span class="line">    public Log4j2Impl(String clazz) &#123;</span><br><span class="line">        Logger logger = LogManager.getLogger(clazz);</span><br><span class="line">        if (logger instanceof AbstractLogger) &#123;</span><br><span class="line">            this.log = new Log4j2AbstractLoggerImpl((AbstractLogger)logger);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            this.log = new Log4j2LoggerImpl(logger);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean isDebugEnabled() &#123;</span><br><span class="line">        return this.log.isDebugEnabled();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean isTraceEnabled() &#123;</span><br><span class="line">        return this.log.isTraceEnabled();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void error(String s, Throwable e) &#123;</span><br><span class="line">        this.log.error(s, e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void error(String s) &#123;</span><br><span class="line">        this.log.error(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void debug(String s) &#123;</span><br><span class="line">        this.log.debug(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void trace(String s) &#123;</span><br><span class="line">        this.log.trace(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void warn(String s) &#123;</span><br><span class="line">        this.log.warn(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样当项目中添加了Log4j2时，Mybatis就可以直接使用它打印Mybatis的日志信息了。<br>Log接口还有很多实现类。</p><ul><li>代理模式</li></ul><p>代理模式是指某一个对象提供一个代理对象，并由代理对象控制原对象的调用。</p><p>代理模式在MyBatis中的典型代表是MapperProxyFactory.</p><p>MapperProxyFactory中的newInstance()方法就是生成一个具体的代理来实现功能的，源码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public class MapperProxyFactory&lt;T&gt; &#123;</span><br><span class="line">    private final Class&lt;T&gt; mapperInterface;</span><br><span class="line">    private final Map&lt;Method, MapperMethod&gt; methodCache = new ConcurrentHashMap();</span><br><span class="line"></span><br><span class="line">    public MapperProxyFactory(Class&lt;T&gt; mapperInterface) &#123;</span><br><span class="line">        this.mapperInterface = mapperInterface;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Class&lt;T&gt; getMapperInterface() &#123;</span><br><span class="line">        return this.mapperInterface;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Map&lt;Method, MapperMethod&gt; getMethodCache() &#123;</span><br><span class="line">        return this.methodCache;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 创建代理类</span><br><span class="line">    protected T newInstance(MapperProxy&lt;T&gt; mapperProxy) &#123;</span><br><span class="line">        return Proxy.newProxyInstance(this.mapperInterface.getClassLoader(), new Class[]&#123;this.mapperInterface&#125;, mapperProxy);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 创建代理类</span><br><span class="line">    public T newInstance(SqlSession sqlSession) &#123;</span><br><span class="line">        MapperProxy&lt;T&gt; mapperProxy = new MapperProxy(sqlSession, this.mapperInterface, this.methodCache);</span><br><span class="line">        return this.newInstance(mapperProxy);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>模板方法模式</li></ul><p>模板方法模式是最常用的设计模式之一，它是指定义一个操作算法的骨架，而将一些步骤的实现延迟到子类中去实现，<br>使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。此模式是基于继承的思想实现代码复用的。</p><p>模板方法在MyBatis中的典型代表是BaseExecutor</p><p>在MyBatis中BaseExecutor实现了大部分SQL执行的逻辑，然后再把几个方法交给子类来实现。<br>它的继承关系如下图所示：<br><img src="/2020/08/11/Mybatis使用了哪些设计模式/BaseExecutor类图.png" alt></p><p>比如doUpdate() 就是交给子类自己去实现的，它在BaseExecutor中的定义如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protected abstract int doUpdate(MappedStatement var1, Object var2) throws SQLException;</span><br></pre></td></tr></table></figure></p><p>在SimpleExecutor中的实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class SimpleExecutor extends BaseExecutor &#123;</span><br><span class="line">    public SimpleExecutor(Configuration configuration, Transaction transaction) &#123;</span><br><span class="line">        super(configuration, transaction);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int doUpdate(MappedStatement ms, Object parameter) throws SQLException &#123;</span><br><span class="line">        Statement stmt = null;</span><br><span class="line"></span><br><span class="line">        int var6;</span><br><span class="line">        try &#123;</span><br><span class="line">            Configuration configuration = ms.getConfiguration();</span><br><span class="line">            StatementHandler handler = configuration.newStatementHandler(this, ms, parameter, RowBounds.DEFAULT, (ResultHandler)null, (BoundSql)null);</span><br><span class="line">            stmt = this.prepareStatement(handler, ms.getStatementLog());</span><br><span class="line">            var6 = handler.update(stmt);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            this.closeStatement(stmt);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return var6;</span><br><span class="line">    &#125;</span><br><span class="line">    // 其余代码省略</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看出SimpleExecutor每次使用完Statement对象之后，都会把它关闭掉，而ReuseExecutor中实现的源码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class ReuseExecutor extends BaseExecutor &#123;</span><br><span class="line">    private final Map&lt;String, Statement&gt; statementMap = new HashMap();</span><br><span class="line"></span><br><span class="line">    public ReuseExecutor(Configuration configuration, Transaction transaction) &#123;</span><br><span class="line">        super(configuration, transaction);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int doUpdate(MappedStatement ms, Object parameter) throws SQLException &#123;</span><br><span class="line">        Configuration configuration = ms.getConfiguration();</span><br><span class="line">        StatementHandler handler = configuration.newStatementHandler(this, ms, parameter, RowBounds.DEFAULT, (ResultHandler)null, (BoundSql)null);</span><br><span class="line">        Statement stmt = this.prepareStatement(handler, ms.getStatementLog());</span><br><span class="line">        return handler.update(stmt);</span><br><span class="line">    &#125;</span><br><span class="line">    // 其余代码省略</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看出。ReuseExecutor每次使用完Statement对象之后不会把它关闭掉。</p><ul><li>装饰器模式</li></ul><p>装饰器模式允许向一个现有的对象添加新的功能，同时又不改变其结构，这种类型的设计模式属于结构型模式。</p><p>装饰器模式在MyBatis模式中的典型代表就是Cache.</p><p>Cache除了有数据存储和缓存的基本功能外，还有其他附加的Cache类，比如先进先出的FifoCache、最近最少使用的LruCache、<br>防止多线程并发访问的SynchronizedCache等众多附加功能的缓存类，Cache所有实现子类如下图所示：<br><img src="/2020/08/11/Mybatis使用了哪些设计模式/Cache类图.png" alt><br>还有部分实现类没展示出来，感兴趣的同学可以自己看下源码。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>介绍了MyBatis源码中的几个主要设计模式：工厂模式、建造者模式、单例模式、适配器模式、代理模式、模板方法模式等。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Mybatis使用了哪些设计模式&quot;&gt;&lt;a href=&quot;#Mybatis使用了哪些设计模式&quot; class=&quot;headerlink&quot; title=&quot;Mybatis使用了哪些设计模式&quot;&gt;&lt;/a&gt;Mybatis使用了哪些设计模式&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;工厂模式&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;工厂模式就是提供一个工厂类，当有客户端需要调用的时候，只调用这个工厂类就可以得到自己想要的结果，从而无需关注某类的具体实现过程。&lt;/p&gt;
&lt;p&gt;工厂模式在MyBatis中的典型代表就是SqlSessionFactory.&lt;/p&gt;
&lt;p&gt;SqlSession是MyBatis中的重要Java接口，可以通过该接口来执行SQL命令，获取映射器实例和管理事务，而SqlSessionFactory&lt;br&gt;正是用来产生SqlSession对象，所以它在MyBatis中是比较核心的接口之一。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="进阶" scheme="/categories/%E8%BF%9B%E9%98%B6/"/>
    
    
      <category term="源码" scheme="/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot启动流程</title>
    <link href="/2020/08/11/SpringBoot%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/"/>
    <id>/2020/08/11/SpringBoot启动流程/</id>
    <published>2020-08-10T16:00:00.000Z</published>
    <updated>2020-08-11T14:52:47.315Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SpringBoot启动流程"><a href="#SpringBoot启动流程" class="headerlink" title="SpringBoot启动流程"></a>SpringBoot启动流程</h1><p>我们知道SpringBoot程序入口是SpringApplication.run(Application.class, args)方法，<br>那么就从run()方法开始分析吧。源码如下：<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">public ConfigurableApplicationContext run(String... args) &#123;</span><br><span class="line">    // 1、创建并启动计时监控类</span><br><span class="line">    StopWatch stopWatch = new StopWatch();</span><br><span class="line">    stopWatch.start();</span><br><span class="line">    </span><br><span class="line">    // 2、声明应用上下文对象和异常报告集合</span><br><span class="line">    ConfigurableApplicationContext context = null;</span><br><span class="line">    Collection&lt;SpringBootExceptionReporter&gt; exceptionReporters = new ArrayList();</span><br><span class="line">    </span><br><span class="line">    // 3、设置系统属性headless的值</span><br><span class="line">    this.configureHeadlessProperty();</span><br><span class="line">    </span><br><span class="line">    // 4、创建所有Spring运行监听器并发布应用启动事件</span><br><span class="line">    SpringApplicationRunListeners listeners = this.getRunListeners(args);</span><br><span class="line">    listeners.starting();</span><br><span class="line"></span><br><span class="line">    Collection exceptionReporters;</span><br><span class="line">    try &#123;</span><br><span class="line">    </span><br><span class="line">        // 5 处理args参数</span><br><span class="line">        ApplicationArguments applicationArguments = new DefaultApplicationArguments(args);</span><br><span class="line">        </span><br><span class="line">        // 6 准备环境</span><br><span class="line">        ConfigurableEnvironment environment = this.prepareEnvironment(listeners, applicationArguments);</span><br><span class="line">        this.configureIgnoreBeanInfo(environment);</span><br><span class="line">        </span><br><span class="line">        // 7 创建Banner的打印类</span><br><span class="line">        Banner printedBanner = this.printBanner(environment);</span><br><span class="line">        </span><br><span class="line">        // 8 创建应用上下文</span><br><span class="line">        context = this.createApplicationContext();</span><br><span class="line">        </span><br><span class="line">        // 9 实例化异常报告器</span><br><span class="line">        exceptionReporters = this.getSpringFactoriesInstances(SpringBootExceptionReporter.class, new Class[]&#123;ConfigurableApplicationContext.class&#125;, context);</span><br><span class="line">        </span><br><span class="line">        // 10 准备应用上下文</span><br><span class="line">        this.prepareContext(context, environment, listeners, applicationArguments, printedBanner);</span><br><span class="line">        </span><br><span class="line">        // 11 刷新应用上下文</span><br><span class="line">        this.refreshContext(context);</span><br><span class="line">        </span><br><span class="line">        // 12 应用上下文刷新之后的事件处理</span><br><span class="line">        this.afterRefresh(context, applicationArguments);</span><br><span class="line">        </span><br><span class="line">        // 13 停止计时监控类</span><br><span class="line">        stopWatch.stop();</span><br><span class="line">        </span><br><span class="line">        // 14 输出日志记录执行主类名、时间信息</span><br><span class="line">        if (this.logStartupInfo) &#123;</span><br><span class="line">            (new StartupInfoLogger(this.mainApplicationClass)).logStarted(this.getApplicationLog(), stopWatch);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 15 发布应用上下文启动完成时间</span><br><span class="line">        listeners.started(context);</span><br><span class="line">        </span><br><span class="line">        // 16 执行所有Runner运行器</span><br><span class="line">        this.callRunners(context, applicationArguments);</span><br><span class="line">    &#125; catch (Throwable var10) &#123;</span><br><span class="line">        this.handleRunFailure(context, var10, exceptionReporters, listeners);</span><br><span class="line">        throw new IllegalStateException(var10);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        // 17 发布应用上下文就绪时间</span><br><span class="line">        listeners.running(context);</span><br><span class="line">        </span><br><span class="line">        // 18、返回应用上下文对象</span><br><span class="line">        return context;</span><br><span class="line">    &#125; catch (Throwable var9) &#123;</span><br><span class="line">        this.handleRunFailure(context, var9, exceptionReporters, (SpringApplicationRunListeners)null);</span><br><span class="line">        throw new IllegalStateException(var9);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>以上源码看出SpringBoot的启动总共分为以下18个步骤：<br>1、<strong>创建并启动计时监控类</strong></p><p>此计时器是为了监控并记录SpringBoot应用启动的时间，它会记录当前任务名称，然后开启计时器。</p><p>2、<strong>声明应用上下文对象和异常报告集合</strong></p><p>此过程声明了应用上下文对象和一个异常报告的ArrayList集合</p><p>3、<strong>设置系统属性headless的值</strong></p><p>是抽象窗口工具集，设置为true表示运行一个headless服务器，可以用它来作一些简单的图像处理。</p><p>4、<strong>创建所有Spring运行监听器并发布应用启动事件</strong></p><p>此过程用于获取配置的监听器名称并实例化所有类</p><p>5、<strong>处理args参数</strong></p><p>声明并创建一个应用参数对象</p><p>6、<strong>准备环境</strong></p><p>创建配置并且绑定环境(通过property sources 和 profiles等配置文件)</p><p>7、<strong>创建Banner的打印类</strong></p><p>启动是会打印Banner图片，我们可以通过实现Banner接口来自定义banner信息，在resources下增加一个banner.txt文件</p><p>8、<strong>创建应用上下文</strong></p><p>根据不同的应用类型来创建不同的ApplicationContext上下文对象</p><p>9、<strong>实例化异常报告器</strong></p><p>getSpringFactoriesInstances()方法来获取配置异常类的名称，并实例化所有的异常处理类</p><p>10、<strong>准备应用上下文</strong></p><p>此方法的主要作用就是把上面已经创建好的对象，传递给prepareContext来准备上下文，例如将环境变量environment对象<br>绑定到上下文中、配置bean生成器以及资源加载器、记录启动日志等操作</p><p>11、<strong>刷新应用上下文</strong></p><p>此番发用于解析配置文件、加载bean对象、并且启动内置的web容器等操作</p><p>12、<strong>应用上下文刷新之后的事件处理</strong></p><p>这个方法的源码是空的，可以做一些自定义的后置处理操作</p><p>13、<strong>停止计时监控类</strong></p><p>停止此过程第一步中的程序计时器，并统计任务的执行信息</p><p>14、<strong>输出日志记录执行主类名、时间信息</strong></p><p>把相关的记录信息、比如类型、时间等信息进行控制台输出</p><p>15、<strong>发布应用上下文启动完成时间</strong></p><p>处罚所有SpringApplicationRunListener监听器的started事件方法</p><p>16、<strong>执行所有Runner运行器</strong></p><p>执行所有的ApplicationRunner和CommandLineRunner运行器</p><p>17、<strong>发布应用上下文就绪时间</strong></p><p>触发所有的SpringApplicationRunListener监听器中的running事件</p><p>18、<strong>返回应用上下文对象</strong></p><p>返回上下文对象</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;SpringBoot启动流程&quot;&gt;&lt;a href=&quot;#SpringBoot启动流程&quot; class=&quot;headerlink&quot; title=&quot;SpringBoot启动流程&quot;&gt;&lt;/a&gt;SpringBoot启动流程&lt;/h1&gt;&lt;p&gt;我们知道SpringBoot程序入口是SpringApplication.run(Application.class, args)方法，&lt;br&gt;那么就从run()方法开始分析吧。源码如下：&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="进阶" scheme="/categories/%E8%BF%9B%E9%98%B6/"/>
    
    
      <category term="源码" scheme="/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>synchronized 和 ReentrantLock区别</title>
    <link href="/2020/08/11/synchronized%20%E5%92%8C%20ReentrantLock%E5%8C%BA%E5%88%AB/"/>
    <id>/2020/08/11/synchronized 和 ReentrantLock区别/</id>
    <published>2020-08-10T16:00:00.000Z</published>
    <updated>2020-08-11T14:52:58.066Z</updated>
    
    <content type="html"><![CDATA[<h1 id="synchronized-和-ReentrantLock区别"><a href="#synchronized-和-ReentrantLock区别" class="headerlink" title="synchronized 和 ReentrantLock区别"></a>synchronized 和 ReentrantLock区别</h1><h2 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h2><ul><li>synchronized属于独占式悲观锁，是通过JVM隐士实现的，synchronized只允许同一时刻只有一个县城操作资源。</li><li>在java中每个对象都隐士包含一个moniter(监视器)对象，加锁过程其实就是竞争moniter的过程，当线程进入字节码moniterenter指令后<br>,线程持有moniter对象，执行moniterexit时释放moniter对象，当其它线程没有拿到moniter对象时，则需要阻塞等待获取该对象。<a id="more"></a><h2 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h2></li></ul><ul><li>是默认实现Lock接口。它是基于AQS(队列同步器)实现的，它默认是通过非公平锁实现的，在它内部有一个state的状态字段用于表示锁是否被占用，<br>如果是0则表示锁未占用，此时线程就可以把state改成1，并成功获取锁，而其他未获得锁的线程只能排队去等待获取锁资源。<h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2></li></ul><ul><li>synchronized是JVM隐式实现的，而ReentrantLock是java语言提供的API;</li><li>ReentrantLock可设置公平锁，而synchronized却不行;</li><li>ReentrantLock只能修改代码块，而synchronized可以用于修饰方法、代码块等;</li><li>ReentrantLock需要手动加锁和释放锁，如果忘记释放锁，则或造成资源被永久占用，而synchronized无需手工释放锁;</li><li>ReentrantLock可以知道是否成功获得了锁，而synchronized却不行<h2 id="ReentrantLock源码分析"><a href="#ReentrantLock源码分析" class="headerlink" title="ReentrantLock源码分析"></a>ReentrantLock源码分析</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public ReentrantLock() &#123;</span><br><span class="line">    // 非公平锁</span><br><span class="line">    sync = new NonfairSync();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">* 可以通过参数控制非公平还是公平锁来实现线程的调度</span><br><span class="line">**/</span><br><span class="line">public ReentrantLock(boolean fair) &#123;</span><br><span class="line">    sync = fair ? new FairSync() : new NonfairSync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="公平锁与非公平锁"><a href="#公平锁与非公平锁" class="headerlink" title="公平锁与非公平锁"></a>公平锁与非公平锁</h3><p>公平锁的含义是线程需要按照请求的顺序来获得锁；而非公平锁则允许<strong>插队</strong>的情况存在。<strong>插队</strong>指的是，在线程发送请求的同事该锁的<br>状态恰好变成了可用，那么此线程就可以跳过队列中所有排队的线程，直接拥有该锁。<br>而公平锁由于挂起和恢复所以存在一定的开销，因此性能不如非公平锁，所以ReentrantLock和synchronized默认都是非公平锁的实现方式。<br>reentrantLock是通过lock() 来获取锁，并通过unLock()释放锁，伪代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Lock lock = new ReentrantLock();</span><br><span class="line">try &#123;</span><br><span class="line">    // 加锁</span><br><span class="line">    lock.lock();</span><br><span class="line">    // 业务代码....</span><br><span class="line">&#125; catch (Exception e)</span><br><span class="line">&#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">    // 释放锁</span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>ReentrantLock中的lock是通过sync.lock()实现的。但Sync类中的lock()是一个抽象方法，需要子类NonfairSync或则FairSync去实现，</p><ul><li><p>NonfairSync中的lock()源码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">final void lock() &#123;</span><br><span class="line">    if (compareAndSetState(0, 1))</span><br><span class="line">        // 将当前线程设置为次所的持有者</span><br><span class="line">        setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">    else</span><br><span class="line">        acquire(1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>FairSync中的lock()源码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">final void lock() &#123;</span><br><span class="line">    acquire(1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>可以看出非公平锁比公平锁只多了一行compareAndSetState方法，该方法是舱室将state值由0置换为1，如果设置成功的话，则说明当前没有其他线程持有该锁，<br>不用再去排队了，可以直接占用该锁，否则需要通过acquire()方法去排队。</p><ul><li>acquire()方法源码：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public final void acquire(int arg) &#123;</span><br><span class="line">    if (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>acquire方法尝试获取锁，如果获取锁失败，泽把它加入到阻塞队列中。来看tryAcquire()的源码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">protected final boolean tryAcquire(int acquires) &#123;</span><br><span class="line">    final Thread current = Thread.currentThread();</span><br><span class="line">    int c = getState();</span><br><span class="line">    if (c == 0) &#123;</span><br><span class="line">        // 公平锁比非公平锁多了一行代码  !hasQueuedPredecessors()</span><br><span class="line">        if (compareAndSetState(0, acquires)) &#123;// 尝试获取锁</span><br><span class="line">            setExclusiveOwnerThread(current); // 获取成功，标记被抢占</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else if (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        int nextc = c + acquires;</span><br><span class="line">        if (nextc &lt; 0)</span><br><span class="line">            throw new Error(&quot;Maximum lock count exceeded&quot;);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>对于此方法来说，公平锁比非公平锁只多一行代码!hasQueuedPredecessors()，它用来查看队列中是否有比它等待事件更久的线程，如果没有，就尝试一下是否能获取到锁，<br>如果获取成功，则标记为已经被占用。</p><p>如果获取锁失败，则调用addWaiter()方法把线程包装成Node对象，同时放入到队列中，但addWaiter方法并会不尝试获取锁，如果获取失败，<br>则此节点会被挂起，源码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// 队列中的线程尝试获取锁，失败则会被挂起</span><br><span class="line">final boolean acquireQueued(final Node node, int arg) &#123;</span><br><span class="line">    boolean failed = true; // 获取锁是否成功的状态标识</span><br><span class="line">    try &#123;</span><br><span class="line">        boolean interrupted = false; // 线程是否被终端</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            // 获取前一个节点(前驱结点)</span><br><span class="line">            final Node p = node.predecessor();</span><br><span class="line">            // 当前节点为头节点的下一个节点是，有权尝试获取锁</span><br><span class="line">            if (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node); // 获取成功，将当前节点设置为head节点</span><br><span class="line">                p.next = null; // 原head节点出队  等待被GC help GC</span><br><span class="line">                failed = false; // 获取成功</span><br><span class="line">                return interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            // 判断获取锁失败后是否可以挂起</span><br><span class="line">            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                // 线程被终端，返回true</span><br><span class="line">                interrupted = true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        if (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>该方法会使用for (;;)无限循环的方式来舱室获取锁，若获取失败，则调用shouldParkAfterFailedAcquire()方法，尝试被挂起当前线程。<br>源码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 判断线程是否可以被挂起</span><br><span class="line"> */</span><br><span class="line">private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) &#123;</span><br><span class="line">    // 获得前驱节点的状态</span><br><span class="line">    int ws = pred.waitStatus;</span><br><span class="line">    // 前驱节点的状态为SIGNAL，当前线程可以被挂起(阻塞)</span><br><span class="line">    if (ws == Node.SIGNAL)</span><br><span class="line">        </span><br><span class="line">        return true;</span><br><span class="line">    if (ws &gt; 0) &#123;</span><br><span class="line">        </span><br><span class="line">        do &#123;</span><br><span class="line">            // 若前驱节点状态为CANCELED ,那就一直往前找，直到找到一个正常等待的状态为止</span><br><span class="line">            node.prev = pred = pred.prev;</span><br><span class="line">        &#125; while (pred.waitStatus &gt; 0);</span><br><span class="line">        // 并将当前节点排在它后边</span><br><span class="line">        pred.next = node;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // 把前驱节点的状态修改为SIGNAL</span><br><span class="line">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>线程入列被挂起的前提条件是，前驱节点的状态为SIGNAL，SIGNAL状态的含义是后继节点处于等待状态，当前节点释放锁后将会唤醒后继节点。<br>所以在上面这段代码中，会先判断前驱节点的状态，如果为SIGNAL，则当前线程可以被挂起返回true;如果前驱节点的状态&gt;0,则表示前驱节点取消了<br>，这个时候需要一直往前找，直找到最近一个正常等待的前驱节点，然后把它作为自己的前驱节点；如果前驱节点正常(未取消)，则修改前驱节点状态为SIGNAL。</p><p>到这里整个加锁的流程就已经走完了，最后的情况是，没有拿到锁的线程会在队列中被挂起，知道拥有锁的线程释放锁之后，才会唤醒其他的线程去获取锁资源。</p><h2 id="JDK1-6锁优化"><a href="#JDK1-6锁优化" class="headerlink" title="JDK1.6锁优化"></a>JDK1.6锁优化</h2><ul><li>自适应自旋锁<br>jdk1.6引入了自适应自旋锁意味着自旋的时间不再是固定的时间了，比如在同一个锁对象上，如果通过自选等待成功获取了锁，那个虚拟机就会任务，<br>它下一次很有可能也会成功(通过自旋获取到的锁)，一次允许自旋等待的时间会相对的比较长，而当某个锁通过自旋很少成功获得过锁，那么以后在获取该锁<br>时，可能会忽略掉自旋的过程，以避免浪费CPU资源，这就是<strong>自适应自旋锁</strong>的功能。</li><li>锁升级<br>锁升级其实就是从偏向锁到轻量锁再到重量级锁升级的过程，这是JDK1.6提供的优化功能，也成为锁膨胀。</li><li>偏向锁<br>偏向锁是指在无竞争的情况下设置的一种锁状态。偏向锁的意思是它会偏向于第一个获取它的线程。当锁对象第一次被获取到之后，回到此对象<br>头设置标识为”01”,标识偏向锁的模式，并且在对象头中记录此线程的ID,这种情况下，如果是持有偏向锁的线程每次在进入，不再进行任何同步操作，<br>如Locking、Unlocking等，直到另一个线程尝试获取此锁的时候，偏向锁模式才会<strong>结束</strong>。偏向锁可以提供带有同步但无竞争的程序性能。但如果在多数锁总会被不同的线程访问时，偏向锁模式<br>就比较多余了，此时可以通过-XX:UserBiasedLocking来禁用偏向锁以提升性能。</li><li>轻量锁<br>轻量锁是相对于重量锁而言的，在JDK1.6之前，synchronized是通过操作系统的互斥量来实现的，这种实现方式需要在用户态和核心态之间转换，有很大的性能消耗，这种传统<br>实现锁的方式被称之为重量锁。而轻量锁是通过<strong>比较并交换</strong>(CAS, Compare And Swap)来实现的，它对比的是线程和对象的Mark Word(对象头中的一个区域)，<br>如果更新成功则表示线程成功拥有此锁；如果失败，虚拟机会先检查对象的Mark Word是否指向当前线程的栈帧，如果是，则说明当前线程已经拥有此锁，<br>否则，则说明此锁被其它线程占用了。当两个以上的线程争抢此锁时，轻量锁就膨胀成为重量级锁，这就是锁升级的过程，也是JDK1.6锁优化的内容。<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2>synchronized刚开始为偏向锁，随着锁竞争越来越激烈，会升级为轻量级锁和重量级锁。如果大多数锁被不同的线程锁争抢就不建议使用偏向锁。</li></ul><p>reentrantLock构造公平和非公平锁，以及介绍了自适应自旋锁的实现过程，以及synchronized的三种锁状态和锁升级的执行流程。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;synchronized-和-ReentrantLock区别&quot;&gt;&lt;a href=&quot;#synchronized-和-ReentrantLock区别&quot; class=&quot;headerlink&quot; title=&quot;synchronized 和 ReentrantLock区别&quot;&gt;&lt;/a&gt;synchronized 和 ReentrantLock区别&lt;/h1&gt;&lt;h2 id=&quot;synchronized&quot;&gt;&lt;a href=&quot;#synchronized&quot; class=&quot;headerlink&quot; title=&quot;synchronized&quot;&gt;&lt;/a&gt;synchronized&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;synchronized属于独占式悲观锁，是通过JVM隐士实现的，synchronized只允许同一时刻只有一个县城操作资源。&lt;/li&gt;
&lt;li&gt;在java中每个对象都隐士包含一个moniter(监视器)对象，加锁过程其实就是竞争moniter的过程，当线程进入字节码moniterenter指令后&lt;br&gt;,线程持有moniter对象，执行moniterexit时释放moniter对象，当其它线程没有拿到moniter对象时，则需要阻塞等待获取该对象。&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
      <category term="进阶" scheme="/categories/%E8%BF%9B%E9%98%B6/"/>
    
    
      <category term="Java" scheme="/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>动态代理是如何实现的？JDK Proxy和CGlib有什么区别</title>
    <link href="/2020/08/11/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9FJDK%20Proxy%E5%92%8CCGlib%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/"/>
    <id>/2020/08/11/动态代理是如何实现的？JDK Proxy和CGlib有什么区别/</id>
    <published>2020-08-10T16:00:00.000Z</published>
    <updated>2020-08-11T14:53:02.101Z</updated>
    
    <content type="html"><![CDATA[<h1 id="动态代理是如何实现的？JDK-Proxy和CGlib有什么区别"><a href="#动态代理是如何实现的？JDK-Proxy和CGlib有什么区别" class="headerlink" title="动态代理是如何实现的？JDK Proxy和CGlib有什么区别"></a>动态代理是如何实现的？JDK Proxy和CGlib有什么区别</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>动态代理的常用实现方式是反射。反射机制是指程序在运行期间可以访问、检测和修改其本身状态或行为的一种能力，使用反射我们可以调用一个类对象，以及类对象<br>中包含的属性及方法。</p><p>但动态代理不只有反射一种实现方式。例如：动态代理可以通过CGlib来实现，而CGlib是基于ASM(字节码操作)，而非反射实现的。<br>简单来说，动态代理是一种行为方式，而反射或ASM只是一种实现手段而已。<br><a id="more"></a><br>JDK Proxy和CGlib的区别主要体现在以下几方面：</p><ul><li>JDK Proxy是java语言自带的功能，无需通过加载第三方类实现；</li><li>java对JDK Proxy提供稳定的支持，并且会持续升级和更新JDK Proxy，例如jdk8中的JDK Proxy性能相比于之前版本提升喝多</li><li>JDK Proxy是通过拦截器加反射的方式实现的；</li><li>JDK Proxy只能代理继承接口的类；</li><li>JDK Proxy实现和调用起来比较简单；</li><li>CGlib是通过第三方提供的工具，基于ASM实现的，性能比较高；</li><li>CGlib无需通过接口来实现，它是通过实现子类的方式来完成调用的。</li></ul><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><ul><li>JDK Proxy 和 CGlib 的掌握程度。</li><li>Lombok是通过反射实现的吗？</li><li>动态代理和静态代理有什么区别？</li><li>动态代理的使用场景有哪些？</li><li>Spring的动态代理是通过什么方式实现的？</li></ul><p>1、JDK Proxy 动态代理的实现无需引用第三方类，只需要实现InvocationHandler接口，重写invoke()方法即可。代码如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">public class ProxyExample &#123;</span><br><span class="line">    interface Car &#123;</span><br><span class="line">        void running();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class Bus implements Car &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void running() &#123;</span><br><span class="line">            System.out.println(&quot;Bus running&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class Taxi implements Car &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void running() &#123;</span><br><span class="line">            System.out.println(&quot;Taxi running&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class JDKProxy implements InvocationHandler</span><br><span class="line">    &#123;</span><br><span class="line">        private Object target;</span><br><span class="line"></span><br><span class="line">        // 获取代理对象</span><br><span class="line">        public Object getInstance(Object target) &#123;</span><br><span class="line">            this.target = target;</span><br><span class="line">            // 取得代理对象</span><br><span class="line">            return Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(),this);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * 执行代理方法</span><br><span class="line">         * @param proxy  代理对象</span><br><span class="line">         * @param method  代理方法</span><br><span class="line">         * @param args  方法参数</span><br><span class="line">         * @return</span><br><span class="line">         * @throws Throwable</span><br><span class="line">         */</span><br><span class="line">        @Override</span><br><span class="line">        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">            System.out.println(&quot;动态代理之前的业务处理。。。。。。&quot;);</span><br><span class="line">            Object invoke = method.invoke(target, args);</span><br><span class="line">            return invoke;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        JDKProxy jdkProxy = new JDKProxy();</span><br><span class="line">        Car car = (Car) jdkProxy.getInstance(new Taxi());</span><br><span class="line">        car.running();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">动态代理之前的业务处理。。。。。。</span><br><span class="line">Taxi running</span><br></pre></td></tr></table></figure></p><p>核心就是实现InvocationHandler接口，中的invoke方法。</p><p>动态代理中有一个重要的角色就是代理器，它用于统一管理被代理的对象，显然InvocationHandler就是这个代理器，而<br>invoke()方法则是触发代理的执行方法，我们通过实现InvocationHandler接口来拥有代理的能力。</p><p>2、CGlib的实现<br>使用前，需要引入pom坐标<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;cglib&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;cglib&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></p><p>实现代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">public class CGlibExample &#123;</span><br><span class="line"></span><br><span class="line">    static class Car &#123;</span><br><span class="line"></span><br><span class="line">        public void running() &#123;</span><br><span class="line">            System.out.println(&quot;this car is running&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static  class  CGlibProxy implements MethodInterceptor &#123;</span><br><span class="line">        // 代理对象</span><br><span class="line">        private Object target;</span><br><span class="line"></span><br><span class="line">        public Object getInstance( Object target)</span><br><span class="line">        &#123;</span><br><span class="line">            this.target = target;</span><br><span class="line">            Enhancer enhancer = new Enhancer();</span><br><span class="line">            // 设置父类为实例类</span><br><span class="line">            enhancer.setSuperclass(this.target.getClass());</span><br><span class="line">            // 回调方法</span><br><span class="line">            enhancer.setCallback(this);</span><br><span class="line">            // 创建代理对象</span><br><span class="line">            return  enhancer.create();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable &#123;</span><br><span class="line">            System.out.println(&quot;方法调用前业务处理&quot;);</span><br><span class="line">            // 执行方法调用</span><br><span class="line">            Object result = methodProxy.invokeSuper(o, objects);</span><br><span class="line">            return result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        CGlibProxy cGlibProxy = new CGlibProxy();</span><br><span class="line"></span><br><span class="line">        Car car = (Car)cGlibProxy.getInstance(new Car());</span><br><span class="line">        car.running();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>执行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">方法调用前业务处理</span><br><span class="line">this car is running</span><br></pre></td></tr></table></figure></p><p>可以看出CGlib和JDK Proxy的实现代理比较类似，都是通过实现代理器的接口，再调用某一个方法完成动态代理的，<br>唯一不同的是。CGlib在初始化被代理类时，是通过Enhancer对象把代理对象设置为被代理类的子类来实现动态代理的。<br>因此被代理类不能被关键字final修饰，如果被final修饰，再使用Enhancer色织父类时会报错，动态代理的构建会失败。</p><p>3、Lombok原理分析<br>Lombok会根据自己的注解处理器动态修改AST,增加新的代码(节点)，在这一切执行之后就生成了最终的字节码(.class)文件。</p><p>4、动态代理只是点扩充<br>动态代理和静态代理区别？静态代理其实是事先写好代理类，可以手工编写也可以使用工具生成，但它的确定是每个业务类都要对应<br>一个代理类，特别不灵活也不方便，于是就有了动态代理。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>动态代理的常见使用的场景有RPC框架的封装、AOP的实现、JDBC的连接等。</p><p>Spring框架中同时使用了两种动态代理JDK Proxy和CgLib ，当Bean实现了接口时，Spring就会使用JDK Proxy,在没有实现接口时<br>就会使用CGlib,我们也可以配置中指定强制使用CGlib，只需要在Spring配置中添加&lt;aop:aspect-autoproxy proxy-target-class=”true”/&gt;即可。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;动态代理是如何实现的？JDK-Proxy和CGlib有什么区别&quot;&gt;&lt;a href=&quot;#动态代理是如何实现的？JDK-Proxy和CGlib有什么区别&quot; class=&quot;headerlink&quot; title=&quot;动态代理是如何实现的？JDK Proxy和CGlib有什么区别&quot;&gt;&lt;/a&gt;动态代理是如何实现的？JDK Proxy和CGlib有什么区别&lt;/h1&gt;&lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h2&gt;&lt;p&gt;动态代理的常用实现方式是反射。反射机制是指程序在运行期间可以访问、检测和修改其本身状态或行为的一种能力，使用反射我们可以调用一个类对象，以及类对象&lt;br&gt;中包含的属性及方法。&lt;/p&gt;
&lt;p&gt;但动态代理不只有反射一种实现方式。例如：动态代理可以通过CGlib来实现，而CGlib是基于ASM(字节码操作)，而非反射实现的。&lt;br&gt;简单来说，动态代理是一种行为方式，而反射或ASM只是一种实现手段而已。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="进阶" scheme="/categories/%E8%BF%9B%E9%98%B6/"/>
    
    
      <category term="Java" scheme="/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>如何手写一个消息队列和延迟消息队列</title>
    <link href="/2020/08/11/%E5%A6%82%E4%BD%95%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AA%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%92%8C%E5%BB%B6%E8%BF%9F%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    <id>/2020/08/11/如何手写一个消息队列和延迟消息队列/</id>
    <published>2020-08-10T16:00:00.000Z</published>
    <updated>2020-08-11T14:53:11.795Z</updated>
    
    <content type="html"><![CDATA[<h1 id="如何手写一个消息队列和延迟消息队列"><a href="#如何手写一个消息队列和延迟消息队列" class="headerlink" title="如何手写一个消息队列和延迟消息队列"></a>如何手写一个消息队列和延迟消息队列</h1><ul><li><p>RabbitMQ中有3个重要的概念：生产者、消费者和代理</p><ul><li>生产者：消息的创建者，负责创建和推送数据到消息服务器</li><li>消费者：消息的接收方，用于处理数据和确认消息</li><li>代理：也就是RabbitMQ服务本身，它用于扮演”快递”的角色，因为它本身并不产生消息，只是扮演了”快递”的角色，把消息进行暂存和传递。</li></ul></li><li><p>RabbitMQ具备以下几个优点：</p><ul><li><strong>支持持久化</strong>，RabbtiMQ支持磁盘持久化功能，保证了消息不会丢失；</li><li>高并发，RabbitMQ使用Erlang开发语言，Erlang是为电话交换机开发的语言，天生只带高并发光环和高可用性</li><li>支持分布式集群</li><li>支持多种语言</li><li>支持消息确认，支持消息消费确认(ack),保证了每条消息可以正常被消费</li><li>支持很多插件</li></ul></li><li>RabbitMQ的消息类型，分为以下四种：<ul><li>direct(默认类型)模式：此模式为一对一的发送方式，也就是一条消息指挥发送给一个消费者</li><li>headers模式：允许你匹配消息的header而非路由键(RoutingKey),除此之外headers和direct模式的使用完全一致，<br>但是因为headers匹配的性能很差，几乎不会被用到；</li><li>fanout模式：为多播模式。会把一个消息分发给所有的订阅者；</li><li>topic模式：为主题订阅模式，允许使用通配符(#、*)匹配一个或多个消息，我可以使用”cn.#”匹配对个前缀是”cn.xxx”<br>的消息；<a id="more"></a><h2 id="自定义消息队列"><a href="#自定义消息队列" class="headerlink" title="自定义消息队列"></a>自定义消息队列</h2>我们可使用Queue来实现消息队列，Queue大体可分为以下三类：</li></ul></li></ul><ul><li>双端队列(Deque)，是Queue的子类也是Queue的补充类，头部和尾部都支持元素插入和获取；</li></ul><ul><li><strong>阻塞队列</strong>指的是在元素操作时，如果没有成功，会阻塞等待执行，比如添加元素时，如果队列元素已满，队列则会阻塞直到有空位时，再插入</li><li><strong>非阻塞队列</strong>和阻塞队列相反，它会直接返回操作的结果，而非阻塞等待操作，对端队列也属于非阻塞队列</li></ul><p>自定义消息队列的实现代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public class CustomQueue &#123;</span><br><span class="line"></span><br><span class="line">    // 定义消息队列</span><br><span class="line">    private static Queue&lt;String&gt; queue = new LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        producer();</span><br><span class="line">        </span><br><span class="line">        consumer();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 生产消息</span><br><span class="line">     */</span><br><span class="line">    private static void producer() &#123;</span><br><span class="line">        queue.add(&quot;1&quot;);</span><br><span class="line">        queue.add(&quot;2&quot;);</span><br><span class="line">        queue.add(&quot;3&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 消费消息</span><br><span class="line">     */</span><br><span class="line">    private static void consumer() &#123;</span><br><span class="line">        while (!queue.isEmpty()) &#123;</span><br><span class="line">            System.out.println(queue.poll());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></table></figure></p><p>可以看出消息是以先进先出顺序进行消费的。</p><p>实现之定义延迟队列需要实现Delayed接口，重写getDelay()方法，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">public class CustomDelayQueue &#123;</span><br><span class="line">    // 延迟消息队列</span><br><span class="line">    private static DelayQueue delayQueue = new DelayQueue();</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        producer();</span><br><span class="line"></span><br><span class="line">        consumer();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 生产消息</span><br><span class="line">     */</span><br><span class="line">    private static void producer() &#123;</span><br><span class="line">        delayQueue.put(new MyDelay(3000, &quot;消息001&quot;));</span><br><span class="line">        delayQueue.put(new MyDelay(1000, &quot;消息002&quot;));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 消费消息</span><br><span class="line">     */</span><br><span class="line">    private static void consumer() throws InterruptedException &#123;</span><br><span class="line">        System.out.println(&quot;开始执行时间：&quot; + DateFormat.getDateTimeInstance().format(new Date()));</span><br><span class="line">        while (!delayQueue.isEmpty()) &#123;</span><br><span class="line">            System.out.println(delayQueue.take());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;结束执行时间：&quot; + DateFormat.getDateTimeInstance().format(new Date()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class MyDelay implements Delayed &#123;</span><br><span class="line">        // 延迟截止时间</span><br><span class="line">        long delayTime = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        private String msg;</span><br><span class="line"></span><br><span class="line">        public String getMsg() &#123;</span><br><span class="line">            return msg;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void setMsg(String msg) &#123;</span><br><span class="line">            this.msg = msg;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public MyDelay(long delayTime, String msg) &#123;</span><br><span class="line">            this.delayTime = (delayTime + this.delayTime);</span><br><span class="line">            this.msg = msg;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 获取剩余时间</span><br><span class="line">        @Override</span><br><span class="line">        public long getDelay(TimeUnit unit) &#123;</span><br><span class="line">            return unit.convert(delayTime - System.currentTimeMillis(), TimeUnit.MILLISECONDS);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 队列里元素的排序依据</span><br><span class="line">        @Override</span><br><span class="line">        public int compareTo(Delayed o) &#123;</span><br><span class="line">            if(this.getDelay(TimeUnit.MILLISECONDS) &gt; o.getDelay(TimeUnit.MILLISECONDS))</span><br><span class="line">            &#123;</span><br><span class="line">                return 1;</span><br><span class="line">            &#125;</span><br><span class="line">            else if(this.getDelay(TimeUnit.MILLISECONDS) &lt; o.getDelay(TimeUnit.MILLISECONDS))</span><br><span class="line">            &#123;</span><br><span class="line">                return -1;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                return 0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public String toString() &#123;</span><br><span class="line">            return &quot;MyDelay&#123;&quot; +</span><br><span class="line">                    &quot;delayTime=&quot; + delayTime +</span><br><span class="line">                    &quot;, msg=&apos;&quot; + msg + &apos;\&apos;&apos; +</span><br><span class="line">                    &apos;&#125;&apos;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">开始执行时间：2020-8-11 14:33:31</span><br><span class="line">MyDelay&#123;delayTime=1597127612969, msg=&apos;消息002&apos;&#125;</span><br><span class="line">MyDelay&#123;delayTime=1597127614969, msg=&apos;消息001&apos;&#125;</span><br><span class="line">结束执行时间：2020-8-11 14:33:34</span><br></pre></td></tr></table></figure></p><p>可以看出，消息都是先了延迟执行功能</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>介绍了RabbitMQ以及它的消息类型和它的特点等内容，同时还是用Queue的子类LinkedList实现了自定义消息队列，<br>使用DelayQueue实现了自定义延迟消息队列。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;如何手写一个消息队列和延迟消息队列&quot;&gt;&lt;a href=&quot;#如何手写一个消息队列和延迟消息队列&quot; class=&quot;headerlink&quot; title=&quot;如何手写一个消息队列和延迟消息队列&quot;&gt;&lt;/a&gt;如何手写一个消息队列和延迟消息队列&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;RabbitMQ中有3个重要的概念：生产者、消费者和代理&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;生产者：消息的创建者，负责创建和推送数据到消息服务器&lt;/li&gt;
&lt;li&gt;消费者：消息的接收方，用于处理数据和确认消息&lt;/li&gt;
&lt;li&gt;代理：也就是RabbitMQ服务本身，它用于扮演”快递”的角色，因为它本身并不产生消息，只是扮演了”快递”的角色，把消息进行暂存和传递。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;RabbitMQ具备以下几个优点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;支持持久化&lt;/strong&gt;，RabbtiMQ支持磁盘持久化功能，保证了消息不会丢失；&lt;/li&gt;
&lt;li&gt;高并发，RabbitMQ使用Erlang开发语言，Erlang是为电话交换机开发的语言，天生只带高并发光环和高可用性&lt;/li&gt;
&lt;li&gt;支持分布式集群&lt;/li&gt;
&lt;li&gt;支持多种语言&lt;/li&gt;
&lt;li&gt;支持消息确认，支持消息消费确认(ack),保证了每条消息可以正常被消费&lt;/li&gt;
&lt;li&gt;支持很多插件&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;RabbitMQ的消息类型，分为以下四种：&lt;ul&gt;
&lt;li&gt;direct(默认类型)模式：此模式为一对一的发送方式，也就是一条消息指挥发送给一个消费者&lt;/li&gt;
&lt;li&gt;headers模式：允许你匹配消息的header而非路由键(RoutingKey),除此之外headers和direct模式的使用完全一致，&lt;br&gt;但是因为headers匹配的性能很差，几乎不会被用到；&lt;/li&gt;
&lt;li&gt;fanout模式：为多播模式。会把一个消息分发给所有的订阅者；&lt;/li&gt;
&lt;li&gt;topic模式：为主题订阅模式，允许使用通配符(#、*)匹配一个或多个消息，我可以使用”cn.#”匹配对个前缀是”cn.xxx”&lt;br&gt;的消息；&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
      <category term="进阶" scheme="/categories/%E8%BF%9B%E9%98%B6/"/>
    
    
      <category term="Java" scheme="/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>手动实现简易版本地缓存</title>
    <link href="/2020/08/11/%E6%89%8B%E5%86%99%E7%AE%80%E6%98%93%E7%89%88%E7%9A%84%E7%BC%93%E5%AD%98%E5%AE%9E%E7%8E%B0/"/>
    <id>/2020/08/11/手写简易版的缓存实现/</id>
    <published>2020-08-10T16:00:00.000Z</published>
    <updated>2020-08-11T14:53:25.958Z</updated>
    
    <content type="html"><![CDATA[<h1 id="手动实现简易版本地缓存"><a href="#手动实现简易版本地缓存" class="headerlink" title="手动实现简易版本地缓存"></a>手动实现简易版本地缓存</h1><p>先定义一个缓存类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">@Data</span><br><span class="line">@Getter</span><br><span class="line">@Setter</span><br><span class="line">public class MyCache implements Comparable&lt;MyCache&gt;&#123;</span><br><span class="line">    private Object key;</span><br><span class="line"></span><br><span class="line">    // 保证可见性</span><br><span class="line">    private volatile Object value;</span><br><span class="line">    </span><br><span class="line">    // 最后访问时间</span><br><span class="line">    private long lastTime;</span><br><span class="line"></span><br><span class="line">    // 写入时间</span><br><span class="line">    private long writeTime;</span><br><span class="line">    </span><br><span class="line">    // 过期时间</span><br><span class="line">    private long expireTime;</span><br><span class="line">    </span><br><span class="line">    // 缓存命中率</span><br><span class="line">    private Integer hitCount;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int compareTo(MyCache o) &#123;</span><br><span class="line">        return hitCount.compareTo(o.hitCount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><a id="more"></a><p>再定一个全局缓存对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public class CacheGlobal &#123;</span><br><span class="line">    // 全局缓存对象</span><br><span class="line">    public static ConcurrentMap&lt;String, MyCache&gt; cacheConcurrentMap = new ConcurrentHashMap&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>定义过期缓存检测类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public class ExpireThread implements Runnable &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        while (true)</span><br><span class="line">        &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(10);</span><br><span class="line">                // 检查缓存和清除的方法</span><br><span class="line">                expireCache();</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void expireCache() &#123;</span><br><span class="line">        System.out.println(&quot;检测缓存是否过期&quot;);</span><br><span class="line">        for(String key :CacheGlobal.cacheConcurrentMap.keySet())</span><br><span class="line">        &#123;</span><br><span class="line">            MyCache myCache = CacheGlobal.cacheConcurrentMap.get(key);</span><br><span class="line">            long timeoutTime = System.currentTimeMillis() - myCache.getWriteTime();</span><br><span class="line"></span><br><span class="line">            if(myCache.getExpireTime() &gt; timeoutTime)</span><br><span class="line">            &#123;</span><br><span class="line">                //没过期</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            CacheGlobal.cacheConcurrentMap.remove(key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>定义缓存操作工具类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">public class CacheUtils</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    public void put(String key, Object value, long expire)</span><br><span class="line">    &#123;</span><br><span class="line">        if (StringUtils.isBlank(key))</span><br><span class="line">        &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        // 存在则更新</span><br><span class="line">        // TODO 存在线程安全问题，多线程下</span><br><span class="line">        if (CacheGlobal.cacheConcurrentMap.containsKey(key))</span><br><span class="line">        &#123;</span><br><span class="line">            MyCache myCache = CacheGlobal.cacheConcurrentMap.get(key);</span><br><span class="line">            myCache.setHitCount(myCache.getHitCount() + 1);</span><br><span class="line">            myCache.setWriteTime(System.currentTimeMillis());</span><br><span class="line">            myCache.setExpireTime(expire);</span><br><span class="line">            myCache.setLastTime(System.currentTimeMillis());</span><br><span class="line">            myCache.setValue(value);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // 创建缓存</span><br><span class="line">        MyCache myCache = new MyCache();</span><br><span class="line">        myCache.setKey(key);</span><br><span class="line">        myCache.setValue(value);</span><br><span class="line">        myCache.setExpireTime(expire);</span><br><span class="line">        myCache.setWriteTime(System.currentTimeMillis());</span><br><span class="line">        myCache.setLastTime(System.currentTimeMillis());</span><br><span class="line">        myCache.setHitCount(1);</span><br><span class="line">        CacheGlobal.cacheConcurrentMap.put(key, myCache);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public Object get(String key)</span><br><span class="line">    &#123;</span><br><span class="line">        if (StringUtils.isBlank(key))</span><br><span class="line">            return null;</span><br><span class="line">        </span><br><span class="line">        if (CacheGlobal.cacheConcurrentMap.isEmpty())</span><br><span class="line">            return null;</span><br><span class="line">        </span><br><span class="line">        if (!CacheGlobal.cacheConcurrentMap.containsKey(key))</span><br><span class="line">            return null;</span><br><span class="line">        </span><br><span class="line">        MyCache myCache = CacheGlobal.cacheConcurrentMap.get(key);</span><br><span class="line">        </span><br><span class="line">        if (myCache == null)</span><br><span class="line">            return null;</span><br><span class="line">        </span><br><span class="line">        // 惰性删除，判断缓存是否过期</span><br><span class="line">        long timeoutTime = System.currentTimeMillis() - myCache.getWriteTime();</span><br><span class="line">        </span><br><span class="line">        if (myCache.getExpireTime() &lt;= timeoutTime)</span><br><span class="line">        &#123;</span><br><span class="line">            CacheGlobal.cacheConcurrentMap.remove(key);</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        myCache.setHitCount(myCache.getHitCount() + 1);</span><br><span class="line">        myCache.setLastTime(System.currentTimeMillis());</span><br><span class="line">        </span><br><span class="line">        return myCache.getValue();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>测试类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class MyCacheTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        CacheUtils cacheUtils = new CacheUtils();</span><br><span class="line"></span><br><span class="line">        cacheUtils.put(&quot;key&quot;, &quot;测试&quot;, 10);</span><br><span class="line"></span><br><span class="line">        String value = (String)cacheUtils.get(&quot;key&quot;);</span><br><span class="line">        System.out.println(value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;手动实现简易版本地缓存&quot;&gt;&lt;a href=&quot;#手动实现简易版本地缓存&quot; class=&quot;headerlink&quot; title=&quot;手动实现简易版本地缓存&quot;&gt;&lt;/a&gt;手动实现简易版本地缓存&lt;/h1&gt;&lt;p&gt;先定义一个缓存类&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;@Data&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@Getter&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@Setter&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;public class MyCache implements Comparable&amp;lt;MyCache&amp;gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    private Object key;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    // 保证可见性&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    private volatile Object value;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    // 最后访问时间&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    private long lastTime;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    // 写入时间&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    private long writeTime;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    // 过期时间&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    private long expireTime;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    // 缓存命中率&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    private Integer hitCount;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    @Override&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    public int compareTo(MyCache o) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return hitCount.compareTo(o.hitCount);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="进阶" scheme="/categories/%E8%BF%9B%E9%98%B6/"/>
    
    
      <category term="Java" scheme="/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>深克隆和浅克隆的区别和实现方式</title>
    <link href="/2020/08/11/%E6%B7%B1%E5%85%8B%E9%9A%86%E5%92%8C%E6%B5%85%E5%85%8B%E9%9A%86%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/"/>
    <id>/2020/08/11/深克隆和浅克隆的区别和实现方式/</id>
    <published>2020-08-10T16:00:00.000Z</published>
    <updated>2020-08-11T14:53:17.113Z</updated>
    
    <content type="html"><![CDATA[<p>#深克隆和浅克隆的区别和实现方式</p><h2 id="浅克隆"><a href="#浅克隆" class="headerlink" title="浅克隆"></a>浅克隆</h2><p>浅克隆是把原型对象中成员变量为值类型的属性都赋值给克隆对象，把原型对象中的成员变量为引用类型的引用地址也赋值给克隆对象，也就是原型对象以昂<br>中如果有成员变量为引用对象，则引用对象的地址是共享给原型对象和克隆对象。</p><p>简单的锁就是浅克隆只会赋值原型对象，但不会赋值它所引用的对象。</p><h2 id="深克隆"><a href="#深克隆" class="headerlink" title="深克隆"></a>深克隆</h2><p>深克隆就是讲原型对象中的所有类型，无论是值类型还是引用类型，都复制一份给克隆对象，也就是说深克隆会把原型对象和原型对象所引用的对象，<br>都复制一份给克隆对象。<br><a id="more"></a><br>在java语言中要实现克隆则需要实现Colneable接口，并重写Object类中的clone()方法，实现代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">public class CloneExample &#123;</span><br><span class="line">    public static void main(String[] args) throws CloneNotSupportedException &#123;</span><br><span class="line">        People p1 = new People();</span><br><span class="line">        p1.setId(1);</span><br><span class="line">        p1.setName(&quot;zhang&quot;);</span><br><span class="line"></span><br><span class="line">        People p2 = (People) p1.clone();</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;P2: name :&quot; + p2.getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class People implements Cloneable&#123;</span><br><span class="line">        private Integer id;</span><br><span class="line"></span><br><span class="line">        private String name;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        protected Object clone() throws CloneNotSupportedException &#123;</span><br><span class="line">            return super.clone();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public Integer getId() &#123;</span><br><span class="line">            return id;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void setId(Integer id) &#123;</span><br><span class="line">            this.id = id;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public String getName() &#123;</span><br><span class="line">            return name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void setName(String name) &#123;</span><br><span class="line">            this.name = name;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">P2: name :zhang</span><br></pre></td></tr></table></figure></p><h2 id="面试分析"><a href="#面试分析" class="headerlink" title="面试分析"></a>面试分析</h2><ul><li>在java.lang.Object中对clone()方法的约定有哪些？</li><li>在Arrays.copyOf()是深克隆还是浅克隆？</li><li>深克隆的实现方式有几种？</li><li>在java中的克隆为什么要设计出，既要实现空接口Cloneable,还要重写Object的clone()方法？</li></ul><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Creates and returns a copy of this object.  The precise meaning</span><br><span class="line"> * of &quot;copy&quot; may depend on the class of the object. The general</span><br><span class="line"> * intent is that, for any object &#123;@code x&#125;, the expression:</span><br><span class="line"> * &lt;blockquote&gt;</span><br><span class="line"> * &lt;pre&gt;</span><br><span class="line"> * x.clone() != x&lt;/pre&gt;&lt;/blockquote&gt;</span><br><span class="line"> * will be true, and that the expression:</span><br><span class="line"> * &lt;blockquote&gt;</span><br><span class="line"> * &lt;pre&gt;</span><br><span class="line"> * x.clone().getClass() == x.getClass()&lt;/pre&gt;&lt;/blockquote&gt;</span><br><span class="line"> * will be &#123;@code true&#125;, but these are not absolute requirements.</span><br><span class="line"> * While it is typically the case that:</span><br><span class="line"> * &lt;blockquote&gt;</span><br><span class="line"> * &lt;pre&gt;</span><br><span class="line"> * x.clone().equals(x)&lt;/pre&gt;&lt;/blockquote&gt;</span><br><span class="line"> * will be &#123;@code true&#125;, this is not an absolute requirement.</span><br><span class="line"> * &lt;p&gt;</span><br><span class="line"> * By convention, the returned object should be obtained by calling</span><br><span class="line"> * &#123;@code super.clone&#125;.  If a class and all of its superclasses (except</span><br><span class="line"> * &#123;@code Object&#125;) obey this convention, it will be the case that</span><br><span class="line"> * &#123;@code x.clone().getClass() == x.getClass()&#125;.</span><br><span class="line"> * &lt;p&gt;</span><br><span class="line"> * By convention, the object returned by this method should be independent</span><br><span class="line"> * of this object (which is being cloned).  To achieve this independence,</span><br><span class="line"> * it may be necessary to modify one or more fields of the object returned</span><br><span class="line"> * by &#123;@code super.clone&#125; before returning it.  Typically, this means</span><br><span class="line"> * copying any mutable objects that comprise the internal &quot;deep structure&quot;</span><br><span class="line"> * of the object being cloned and replacing the references to these</span><br><span class="line"> * objects with references to the copies.  If a class contains only</span><br><span class="line"> * primitive fields or references to immutable objects, then it is usually</span><br><span class="line"> * the case that no fields in the object returned by &#123;@code super.clone&#125;</span><br><span class="line"> * need to be modified.</span><br><span class="line"> * &lt;p&gt;</span><br><span class="line"> * The method &#123;@code clone&#125; for class &#123;@code Object&#125; performs a</span><br><span class="line"> * specific cloning operation. First, if the class of this object does</span><br><span class="line"> * not implement the interface &#123;@code Cloneable&#125;, then a</span><br><span class="line"> * &#123;@code CloneNotSupportedException&#125; is thrown. Note that all arrays</span><br><span class="line"> * are considered to implement the interface &#123;@code Cloneable&#125; and that</span><br><span class="line"> * the return type of the &#123;@code clone&#125; method of an array type &#123;@code T[]&#125;</span><br><span class="line"> * is &#123;@code T[]&#125; where T is any reference or primitive type.</span><br><span class="line"> * Otherwise, this method creates a new instance of the class of this</span><br><span class="line"> * object and initializes all its fields with exactly the contents of</span><br><span class="line"> * the corresponding fields of this object, as if by assignment; the</span><br><span class="line"> * contents of the fields are not themselves cloned. Thus, this method</span><br><span class="line"> * performs a &quot;shallow copy&quot; of this object, not a &quot;deep copy&quot; operation.</span><br><span class="line"> * &lt;p&gt;</span><br><span class="line"> * The class &#123;@code Object&#125; does not itself implement the interface</span><br><span class="line"> * &#123;@code Cloneable&#125;, so calling the &#123;@code clone&#125; method on an object</span><br><span class="line"> * whose class is &#123;@code Object&#125; will result in throwing an</span><br><span class="line"> * exception at run time.</span><br><span class="line"> *</span><br><span class="line"> * @return     a clone of this instance.</span><br><span class="line"> * @throws  CloneNotSupportedException  if the object&apos;s class does not</span><br><span class="line"> *               support the &#123;@code Cloneable&#125; interface. Subclasses</span><br><span class="line"> *               that override the &#123;@code clone&#125; method can also</span><br><span class="line"> *               throw this exception to indicate that an instance cannot</span><br><span class="line"> *               be cloned.</span><br><span class="line"> * @see java.lang.Cloneable</span><br><span class="line"> */</span><br><span class="line">protected native Object clone() throws CloneNotSupportedException;</span><br></pre></td></tr></table></figure><p>从上面的源码注释信息看出，Object对clone()方法的约定有三条:</p><ul><li>对于所有对象来说，x.clone()!=x赢荡返回true,因为克隆对象与原对象不是同一个对象。</li><li>对于所有对象来说，x.clone().getClass() == x.getClass() 应该返回true,因为克隆对象与原对象的类型是一样的。</li><li>对于所有对象来说，x.clone().equals(x) 应当返回true,因为使用equals比较是，他们的值都是相同的。</li></ul><p><strong>Arrays.copyOf()</strong><br>如果是数组类型，我们可以直接使用Arrays.copyOf()来实现克隆，实现代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">People[] people1 = &#123;new People(1, &quot;zhang&quot;)&#125;;</span><br><span class="line">People[] people2 = Arrays.copyOf(people1, people1.length);</span><br><span class="line"></span><br><span class="line">// 修改原型对象的第一个元素的值</span><br><span class="line">people1[0].setName(&quot;wang&quot;);</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;people1:&quot; + people1[0].getName());</span><br><span class="line">System.out.println(&quot;people2:&quot; + people2[0].getName());</span><br></pre></td></tr></table></figure></p><p>运行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">people1:wang</span><br><span class="line">people2:wang</span><br></pre></td></tr></table></figure></p><p>从结果可以看出。我们在修改克隆对象的第一个元素之后，原型对象的第一个元素也跟着被修改了，这说明了Arrays.copyOf()是一个浅克隆。<br>因为数组比较特殊，数组本身就是引用类型的，因此在使用Arrays.copyOf()其实只是把引用地址复制了一份给克隆对象。如果修改了它的引用对象，那么指向它的<br>(引用地址),所有对象都会发生改变，因此看到的结果是，修改了克隆对象的第一个元素，原型对象也跟着被修改了。</p><p><strong>深克隆实现方式汇总</strong><br>深克隆的实现方式有很多种，大体可以分以下几类：</p><ul><li><p>所有对象都实现克隆方法<br>自定义对象的成员变量都实现Cloneable接口</p></li><li><p>通过构造方法实现深克隆<br>new People(1, “zhang”, new Address(1, “上海”))</p></li><li><p>使用JDK自带的字节流实现深克隆 </p></li><li><p>使用第三方工具实现深克隆，比如Apache Commons Lang<br>People p2 = (People)SerializationUtils.clone(p1);</p></li><li><p>使用JSON工具类实现深克隆，比如Gson、FastJSON等。<br>Gson gson = new Gson();<br>People p2 = gson.fromJson(gson.toJson(p1), People.class);</p></li></ul><p>使用JSON工具类会先把对象转化成字符串，再从字符串转化成新的对象，因为新对象是从字符串转化而来的，因此不会和原型对象有任何关联，<br>这样就实现了深克隆，其他类似的JSON工具类实现方式也是一样的。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>浅克隆和深克隆的概念，以及Object对clone()方法的约定，还演示了数组的copy()方法其实为浅克隆，以及实现深克隆的5种方式。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;#深克隆和浅克隆的区别和实现方式&lt;/p&gt;
&lt;h2 id=&quot;浅克隆&quot;&gt;&lt;a href=&quot;#浅克隆&quot; class=&quot;headerlink&quot; title=&quot;浅克隆&quot;&gt;&lt;/a&gt;浅克隆&lt;/h2&gt;&lt;p&gt;浅克隆是把原型对象中成员变量为值类型的属性都赋值给克隆对象，把原型对象中的成员变量为引用类型的引用地址也赋值给克隆对象，也就是原型对象以昂&lt;br&gt;中如果有成员变量为引用对象，则引用对象的地址是共享给原型对象和克隆对象。&lt;/p&gt;
&lt;p&gt;简单的锁就是浅克隆只会赋值原型对象，但不会赋值它所引用的对象。&lt;/p&gt;
&lt;h2 id=&quot;深克隆&quot;&gt;&lt;a href=&quot;#深克隆&quot; class=&quot;headerlink&quot; title=&quot;深克隆&quot;&gt;&lt;/a&gt;深克隆&lt;/h2&gt;&lt;p&gt;深克隆就是讲原型对象中的所有类型，无论是值类型还是引用类型，都复制一份给克隆对象，也就是说深克隆会把原型对象和原型对象所引用的对象，&lt;br&gt;都复制一份给克隆对象。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="进阶" scheme="/categories/%E8%BF%9B%E9%98%B6/"/>
    
    
      <category term="Java" scheme="/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>锁的理解？如果手动模拟一个死锁</title>
    <link href="/2020/08/11/%E9%94%81%E7%9A%84%E7%90%86%E8%A7%A3/"/>
    <id>/2020/08/11/锁的理解/</id>
    <published>2020-08-10T16:00:00.000Z</published>
    <updated>2020-08-11T14:53:36.840Z</updated>
    
    <content type="html"><![CDATA[<h1 id="锁的理解？如果手动模拟一个死锁"><a href="#锁的理解？如果手动模拟一个死锁" class="headerlink" title="锁的理解？如果手动模拟一个死锁"></a>锁的理解？如果手动模拟一个死锁</h1><p>死锁是指两个线程同时占有两个资源，又在彼此等待对方释放锁资源，如下图所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">public class LockExample &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        deadLock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void deadLock() &#123;</span><br><span class="line">        Object lock1 = new Object();</span><br><span class="line">        Object lock2 = new Object();</span><br><span class="line">        </span><br><span class="line">        // 线程1拥有 lock1 试图获取 lock2</span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">           synchronized (lock1) &#123;</span><br><span class="line">               System.out.println(&quot;获取 lock1 成功&quot;);</span><br><span class="line">               try &#123;</span><br><span class="line">                   TimeUnit.SECONDS.sleep(3);</span><br><span class="line">               &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                   e.printStackTrace();</span><br><span class="line">               &#125;</span><br><span class="line">               </span><br><span class="line">               // 试图获取锁 lock2</span><br><span class="line">               synchronized (lock2) &#123;</span><br><span class="line">                   System.out.println(Thread.currentThread().getName());</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        // 线程2拥有 lock2 试图获取 lock1</span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            synchronized (lock2) &#123;</span><br><span class="line">                System.out.println(&quot;获取 lock2 成功&quot;);</span><br><span class="line">                try &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(3);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                // 试图获取锁 lock1</span><br><span class="line">                synchronized (lock1) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><a id="more"></a><p>执行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">获取 lock1 成功</span><br><span class="line">获取 lock2 成功</span><br></pre></td></tr></table></figure></p><p>可以看出当我们使用线程1拥有锁lock1的同时试图获取lock2，而线程拥有lock2的同时试图获取lock1，这样就会造成彼此都在等待对方<br>释放资源，于是形成了死锁。</p><ul><li>什么是乐观锁和悲观锁？它们的应用都有哪些？乐观锁有什么问题？</li><li>什么是可重入锁？用代码如何实现？它的实现原理是什么？</li><li>什么是共享锁和独占锁?</li></ul><p>1、悲观锁和乐观锁</p><p>悲观锁指的是数据对外界的修改采取保守策略，它认为u线程很同意会把数据修改掉，因此在整个数据被修改的过程中都会采取锁定状态，知道一个线程<br>使用完，其他线程才可以继续使用。<br>我们来看下悲观锁的实现流程，以synchronized为例，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">synchronized (LockExample.class) &#123;</span><br><span class="line">    //....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>反编译之后可以看出被synchronized修饰的代码块，在执行之前先使用monitorenter指令加锁，然后在执行结束之后再使用monitorexit指令<br>释放锁资源，在整个执行期间此代码都是锁定的状态，这就是悲观锁的实现流程。</p><p>Java中的乐观锁大部分都是通过CAS(compare And Swap,比较并交换)操作实现的，CAS是一个多线程同步的原子指令，CAS操作包含三个重要信息，即内存位置和预期原值和新值。<br>如果内存位置的值和预期的原值相等的话，那么就可以把该位置的值更新为新值，否则不做任何修改。</p><p>CAS可能会造成ABA问题，ABA问题指的是，线程拿到了最初的预期原值A,</p><p>2、重入锁<br>可重入锁也叫<strong>递归锁</strong>，指的是同一个线程，如果外面的幻术拥有此锁之后，内层的函数也可以继续获取该锁。在Java语言中ReentrantLock和synchronized都是重入锁。<br>代码演示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class LockExample &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        reentrantLockA();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public synchronized static void reentrantLockA()</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;重入锁A:&quot; + Thread.currentThread().getName());</span><br><span class="line">        reentrantLockB();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private synchronized static void reentrantLockB() &#123;</span><br><span class="line">        System.out.println(&quot;重入锁B:&quot; + Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>执行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">重入锁A:main</span><br><span class="line">重入锁B:main</span><br></pre></td></tr></table></figure></p><p>3、共享锁和独占锁<br>之恩那个被线程持有的锁叫独占锁，可以被多线程持有的锁叫共享锁。<br>独占锁值得是在任何时候最多只能有一个线程持有该锁，比如synchronized就是独占锁，而ReadWriteLock读写锁允许同一时间内有多个线程进行读操作，它属于共享锁。</p><p>4、小结<br>悲观锁的典型应用为synchronized，它的特性为独占式互斥锁；而了关索相比于悲观锁而言，拥有更好的性能，但乐观锁可能会导致ABA问题，常见的解决方式是添加版本号来防止ABA问题<br>的放生。同时，还讲了可重入锁，在java中，synchronized和ReentrantLock都是可重入锁。最后，讲了独占锁和共享锁，其中独占锁可以理解为悲观锁，而共享锁可以<br>理解为乐观锁。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;锁的理解？如果手动模拟一个死锁&quot;&gt;&lt;a href=&quot;#锁的理解？如果手动模拟一个死锁&quot; class=&quot;headerlink&quot; title=&quot;锁的理解？如果手动模拟一个死锁&quot;&gt;&lt;/a&gt;锁的理解？如果手动模拟一个死锁&lt;/h1&gt;&lt;p&gt;死锁是指两个线程同时占有两个资源，又在彼此等待对方释放锁资源，如下图所示：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;public class LockExample &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    public static void main(String[] args) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        deadLock();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    private static void deadLock() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        Object lock1 = new Object();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        Object lock2 = new Object();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        // 线程1拥有 lock1 试图获取 lock2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        new Thread(() -&amp;gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           synchronized (lock1) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;               System.out.println(&amp;quot;获取 lock1 成功&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;               try &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                   TimeUnit.SECONDS.sleep(3);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;               &amp;#125; catch (InterruptedException e) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                   e.printStackTrace();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;               &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;               &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;               // 试图获取锁 lock2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;               synchronized (lock2) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                   System.out.println(Thread.currentThread().getName());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;               &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;).start();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        // 线程2拥有 lock2 试图获取 lock1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        new Thread(() -&amp;gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            synchronized (lock2) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                System.out.println(&amp;quot;获取 lock2 成功&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                try &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    TimeUnit.SECONDS.sleep(3);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &amp;#125; catch (InterruptedException e) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    e.printStackTrace();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                // 试图获取锁 lock1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                synchronized (lock1) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    System.out.println(Thread.currentThread().getName());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;).start();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="进阶" scheme="/categories/%E8%BF%9B%E9%98%B6/"/>
    
    
      <category term="Java" scheme="/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>简单工厂、工厂方法和抽象工厂</title>
    <link href="/2019/12/26/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82/"/>
    <id>/2019/12/26/设计模式/创建型模式/简单工厂/</id>
    <published>2019-12-25T16:00:00.000Z</published>
    <updated>2019-12-26T14:55:30.376Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简单工厂、工厂方法和抽象工厂"><a href="#简单工厂、工厂方法和抽象工厂" class="headerlink" title="简单工厂、工厂方法和抽象工厂"></a>简单工厂、工厂方法和抽象工厂</h1><h2 id="1-简单工厂"><a href="#1-简单工厂" class="headerlink" title="1.简单工厂"></a>1.简单工厂</h2><h3 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h3><p>由一个工厂对象决定创建出哪一种产品类的实例。定义一个创建对象的接口，让子类决定其实例化哪一个类。再使用工厂方法延迟实例化其子类。</p><h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><p>创建型，但不属于GOF23中设计模式。</p><h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><p>工厂类负责创建的对象比较少。客户端(应用层)只知道闯入工厂类的参数，对于如何创建对象(逻辑)不关心。</p><a id="more"></a><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>只需要传入一个正确的参数，就可以获取你所需要的对象而无须知道其创建细节。</p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>工厂类的职责相对过重，增加新的产品需要修改工厂的判断逻辑，违背开闭原则。</p><h3 id="Coding"><a href="#Coding" class="headerlink" title="Coding"></a>Coding</h3><p>先定义一个接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created By Administrator</span></span><br><span class="line"><span class="comment"> * User: VenusZ</span></span><br><span class="line"><span class="comment"> * Date: on 2019/12/25 23:15</span></span><br><span class="line"><span class="comment"> * Desc: 可以是抽象类或者接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Action</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>子类一:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SignAction</span> <span class="keyword">extends</span> <span class="title">Action</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">process</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我正在唱歌"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>子类二:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DanceAction</span> <span class="keyword">extends</span> <span class="title">Action</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">process</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我正在跳舞"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>工厂类:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ActionFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 简单工厂实现方式</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> type  动作类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Action <span class="title">getAction</span><span class="params">(String type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">"sign"</span>.equals(type)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> SignAction();</span><br><span class="line">        &#125;  <span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">"dance"</span>.equals(type)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> DanceAction();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 反射模式下的简单工厂实现</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> clazz</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Action <span class="title">getReflectAction</span><span class="params">(Class clazz)</span> </span>&#123;</span><br><span class="line">        Action action = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            action = (Action) Class.forName(clazz.getName()).newInstance();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> action;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 简单工厂例子</span></span><br><span class="line">        ActionFactory factory = <span class="keyword">new</span> ActionFactory();</span><br><span class="line">        Action sign = factory.getAction(<span class="string">"sign"</span>);</span><br><span class="line">        sign.process();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 反射简单工厂例子</span></span><br><span class="line">        Action action = factory.getReflectAction(DanceAction<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        action.process();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果:</p><p>我正在唱歌<br>我正在跳舞</p><h3 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h3><p>暂无</p><h2 id="2-工厂方法"><a href="#2-工厂方法" class="headerlink" title="2.工厂方法"></a>2.工厂方法</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ul><li>定义一个创建对象的接口但让实现这个接口的类来决定实例化哪个类，工厂方法让类的实例化推迟到子类中进行。</li><li>类型：创建型</li></ul><h3 id="适用场景-1"><a href="#适用场景-1" class="headerlink" title="适用场景"></a>适用场景</h3><ul><li>创建对象需要大量重复代码；</li><li>客户端（应用层）不依赖产品类实例如何被创建、实现等细节；</li><li>一个类通过其子类来指定创建哪个对象；</li></ul><h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h3><ol><li>用户只需要关系所需产品对应的工厂，无须关心创建细节。</li><li>加入新产品符合开闭原则，提高可扩展性。</li></ol><h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><ol><li>类的个数容易过多，增加复杂度</li><li>增加了系统的抽象性和理解难度。</li></ol><h3 id="Coding-1"><a href="#Coding-1" class="headerlink" title="Coding"></a>Coding</h3><p>抽象动作接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Action</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>抽象动作工厂接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ActionFacctory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> Action <span class="title">getAction</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体动作实现类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DanceAction</span> <span class="keyword">extends</span> <span class="title">Action</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">process</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我正在跳舞"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SignAction</span> <span class="keyword">extends</span> <span class="title">Action</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">process</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我正在唱歌"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体动作工厂实现类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DanceActionFactory</span> <span class="keyword">extends</span> <span class="title">ActionFacctory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Action <span class="title">getAction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DanceAction();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SignActionFactory</span> <span class="keyword">extends</span> <span class="title">ActionFacctory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Action <span class="title">getAction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SignAction();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 分别通过不同的工厂类去获取实例对象</span></span><br><span class="line">        SignActionFactory signActionFactory = <span class="keyword">new</span> SignActionFactory();</span><br><span class="line">        signActionFactory.getAction().process();</span><br><span class="line"></span><br><span class="line">        DanceActionFactory danceActionFactory = <span class="keyword">new</span> DanceActionFactory();</span><br><span class="line">        danceActionFactory.getAction().process();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><p>我正在唱歌<br>我正在跳舞</p><h3 id="源码解析-1"><a href="#源码解析-1" class="headerlink" title="源码解析"></a>源码解析</h3><p>暂无</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>​        与简单工厂比较，工厂方法符合开闭原则、单一职责，但如果需要在增加一个具体动作，需要创建对应具体动作实现类和具体动作工厂实现类，这样会成类太多。如果要修成抽象动作，修改的具体动作也比较多。</p><h2 id="3-抽象工厂"><a href="#3-抽象工厂" class="headerlink" title="3.抽象工厂"></a>3.抽象工厂</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><ul><li>抽象工厂模式提供一个创建一系列相关或相互依赖对象的接口。无须指定它们具体的类</li><li>类型：创建型</li></ul><h3 id="适用场景-2"><a href="#适用场景-2" class="headerlink" title="适用场景"></a>适用场景</h3><ul><li>客户端不依赖于产品类实例如何被创建、实现等细节。</li><li>强调一系列相关的产品对象一起使用创建对象需要大量重复的代码。</li><li>提供一个产品类的库，所有的产品以同样的接口出现，从而使客户端不依赖于具体实现。</li></ul><h3 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h3><ol><li>具体产品在应用层代码隔离，无须关系创建细节。</li><li>将一个系列的产品族统一到一起创建。</li></ol><h3 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h3><ol><li>规定了所有可能被创建的产品集合，产品族中扩展新的产品困难，需要修改抽象工厂的接口。</li><li>增加了系统的抽象性和理解难度。</li></ol><h3 id="Coding-2"><a href="#Coding-2" class="headerlink" title="Coding"></a>Coding</h3><p>抽象动作接口类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Action</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>抽象动作笔记接口类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Note</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>抽象动作和笔记工厂接口类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HobbyFactory</span> </span>&#123;</span><br><span class="line">    <span class="function">Action <span class="title">getAction</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Note <span class="title">getNote</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>唱歌动作实现类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SignAction</span> <span class="title">entends</span> <span class="title">Action</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">process</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"培养唱歌爱好"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SignAction</span> <span class="title">entends</span> <span class="title">Note</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">process</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       System.out.println(<span class="string">"记录唱歌笔记"</span>); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跳舞动作实现类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DanceAction</span> <span class="title">entends</span> <span class="title">Action</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">process</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"培养跳舞爱好"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DanceAction</span> <span class="title">entends</span> <span class="title">Note</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">process</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"记录跳舞笔记"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>唱歌工厂类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SignHobbyFactory</span> <span class="keyword">implements</span> <span class="title">HobbyFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Action <span class="title">getAction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span>  <span class="keyword">new</span> SignAction();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Note <span class="title">getNote</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span>  <span class="keyword">new</span> SignNote();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跳舞工厂类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DanceHobbyFactory</span> <span class="keyword">implements</span> <span class="title">HobbyFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Action <span class="title">getAction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span>  <span class="keyword">new</span> DanceAction();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Note <span class="title">getNote</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span>  <span class="keyword">new</span> DanceNote();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HobbyFactory hobbyFactory = <span class="keyword">new</span> DanceHobbyFactory();</span><br><span class="line">        Action action = hobbyFactory.getAction();</span><br><span class="line">        Dance dance = hobbyFactory.getNote();</span><br><span class="line">        action.process();</span><br><span class="line">        dance.process();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><p>培养跳舞爱好</p><p>记录跳舞笔记</p><h3 id="源码解析-2"><a href="#源码解析-2" class="headerlink" title="源码解析"></a>源码解析</h3><p>暂无</p><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>简单工厂违反了最基本的原则；</p><p>工厂方法的工厂个数过多，导致系统庞大；</p><p>抽象工厂增加新的产品族很方便；</p><p><strong>自言自语：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2019</span><span class="number">-12</span><span class="number">-26</span> 平凡的一天，记录下学习工厂方法和抽象工厂的博客，加油，送给未来的自己~</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;简单工厂、工厂方法和抽象工厂&quot;&gt;&lt;a href=&quot;#简单工厂、工厂方法和抽象工厂&quot; class=&quot;headerlink&quot; title=&quot;简单工厂、工厂方法和抽象工厂&quot;&gt;&lt;/a&gt;简单工厂、工厂方法和抽象工厂&lt;/h1&gt;&lt;h2 id=&quot;1-简单工厂&quot;&gt;&lt;a href=&quot;#1-简单工厂&quot; class=&quot;headerlink&quot; title=&quot;1.简单工厂&quot;&gt;&lt;/a&gt;1.简单工厂&lt;/h2&gt;&lt;h3 id=&quot;定义：&quot;&gt;&lt;a href=&quot;#定义：&quot; class=&quot;headerlink&quot; title=&quot;定义：&quot;&gt;&lt;/a&gt;定义：&lt;/h3&gt;&lt;p&gt;由一个工厂对象决定创建出哪一种产品类的实例。定义一个创建对象的接口，让子类决定其实例化哪一个类。再使用工厂方法延迟实例化其子类。&lt;/p&gt;
&lt;h3 id=&quot;类型&quot;&gt;&lt;a href=&quot;#类型&quot; class=&quot;headerlink&quot; title=&quot;类型&quot;&gt;&lt;/a&gt;类型&lt;/h3&gt;&lt;p&gt;创建型，但不属于GOF23中设计模式。&lt;/p&gt;
&lt;h3 id=&quot;适用场景&quot;&gt;&lt;a href=&quot;#适用场景&quot; class=&quot;headerlink&quot; title=&quot;适用场景&quot;&gt;&lt;/a&gt;适用场景&lt;/h3&gt;&lt;p&gt;工厂类负责创建的对象比较少。客户端(应用层)只知道闯入工厂类的参数，对于如何创建对象(逻辑)不关心。&lt;/p&gt;
    
    </summary>
    
      <category term="创建型模式" scheme="/categories/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>单例模式</title>
    <link href="/2019/12/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>/2019/12/25/设计模式/创建型模式/单例模式/</id>
    <published>2019-12-24T16:00:00.000Z</published>
    <updated>2019-12-25T15:50:39.928Z</updated>
    
    <content type="html"><![CDATA[<h3 id="单例模式介绍"><a href="#单例模式介绍" class="headerlink" title="单例模式介绍"></a>单例模式介绍</h3><p><strong>定义</strong>：保证一个类仅有一个实例，并提供一个全局访问点。</p><p><strong>类型</strong>：创建型</p><p><strong>适用场景</strong>：想确保任何情况下都绝对只有一个实例。</p><p><strong>优点</strong>：</p><ul><li>在内存里只有一个实例，减少内存开销；</li></ul><ul><li>可以避免对资源的多重占用；</li></ul><ul><li>设置全局访问点，严格控制访问；</li></ul><p><strong>缺点</strong>：没有借口，不方便扩展</p><p><strong>重点</strong>：</p><ul><li>私有构造器；</li></ul><ul><li>线程安全；</li></ul><ul><li>延迟加载；</li></ul><ul><li>序列化和反序列化安全；</li></ul><ul><li>反射；</li></ul><p><strong>相关设计模式</strong>：</p><ul><li>单例模式和工厂模式；</li></ul><ul><li>单例模式和享元模式；</li></ul><a id="more"></a><h3 id="Coding"><a href="#Coding" class="headerlink" title="Coding"></a>Coding</h3><h4 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a><strong>源码解析</strong></h4><p>AbstractBeanFactory类中的getBean()方法里面的doGetBean方法里面的this.getSingleton(beanName);</p><p>如下图所示</p><p><img src="/2019/12/25/设计模式/创建型模式/单例模式/doGetBean图片.png" alt></p><p><img src="/2019/12/25/设计模式/创建型模式/单例模式/getSingleton图片.png" alt></p><p><img src="/2019/12/25/设计模式/创建型模式/单例模式/getSingleton最终图片.png" alt></p><h4 id="懒汉式单例模式"><a href="#懒汉式单例模式" class="headerlink" title="懒汉式单例模式"></a>懒汉式单例模式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created By VenusJ on 2019/12/25 22:06</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Desc: 懒汉式单例模式  线程不安全  可以在静态方法增加synchronized 关键字来保证线程安全</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazySingleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> LazySingleton singleton = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LazySingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> LazySingleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(singleton == <span class="keyword">null</span>)&#123;</span><br><span class="line">            singleton = <span class="keyword">new</span> LazySingleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="饿汉式单例模式"><a href="#饿汉式单例模式" class="headerlink" title="饿汉式单例模式"></a><strong>饿汉式单例模式</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created By Administrator</span></span><br><span class="line"><span class="comment"> * User: VenusZ</span></span><br><span class="line"><span class="comment"> * Date: on 2019/12/25 22:16</span></span><br><span class="line"><span class="comment"> * Desc: 单例模式 饿汉模式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HungarySingleton</span> <span class="keyword">implements</span> <span class="title">Serializable</span>, <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span>  <span class="keyword">final</span> HungarySingleton hungarySingleton;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加载类时生成唯一一个实例</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        hungarySingleton = <span class="keyword">new</span> HungarySingleton();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">HungarySingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 防止序列化时  破坏单例对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Object <span class="title">readResolve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hungarySingleton;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getInstance();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HungarySingleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hungarySingleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="双重检查单例模式"><a href="#双重检查单例模式" class="headerlink" title="双重检查单例模式"></a><strong>双重检查单例模式</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created By Administrator</span></span><br><span class="line"><span class="comment"> * User: VenusZ</span></span><br><span class="line"><span class="comment"> * Date: on 2019/12/25 22:27</span></span><br><span class="line"><span class="comment"> * Desc: 双重检查单例模式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DoubleCheckSingleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">DoubleCheckSingleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里增加volatile关键字，是为了保持内存可见性和防止指令重排序。保证该变量在线程之间可见，下述步骤2和3可能在多线线程时发生调换</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> DoubleCheckSingleton singleton = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DoubleCheckSingleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(singleton==<span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (DoubleCheckSingleton<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(singleton == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    <span class="comment">// 1 给singleton分配内存</span></span><br><span class="line">                    <span class="comment">// 2 利用构造函数初始成员变量</span></span><br><span class="line">                    <span class="comment">// 3 给singleton对象指向分配的内存空间      这个涉及指令重排和内存屏障知识，这里就不作详细介绍了</span></span><br><span class="line">                    singleton = <span class="keyword">new</span> DoubleCheckSingleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="静态内部类方式"><a href="#静态内部类方式" class="headerlink" title="静态内部类方式"></a><strong>静态内部类方式</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created By Administrator</span></span><br><span class="line"><span class="comment"> * User: VenusZ</span></span><br><span class="line"><span class="comment"> * Date: on 2019/12/25 22:37</span></span><br><span class="line"><span class="comment"> * Desc: 静态内部类单例模式   延迟初始化，来减少创建单利实例的开销</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticInnerClassSingleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">StaticInnerClassSingleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> StaticInnerClassSingleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> InnerClass.singleton;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在内部类中实例化对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerClass</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> StaticInnerClassSingleton singleton = <span class="keyword">new</span> StaticInnerClassSingleton();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="序列化破坏单例模式"><a href="#序列化破坏单例模式" class="headerlink" title="序列化破坏单例模式"></a>序列化破坏单例模式</h4><p>对应类需要实现Serializable接口，才能进行序列化和反序列化。</p><p>如需解决序列化和反序列化破话单例模式的话，方案可以在对应类中增加对应方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * \* Created with IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> * \* User: VenusZ</span></span><br><span class="line"><span class="comment"> * \* Date: 2019/12/25</span></span><br><span class="line"><span class="comment"> * \* Time: 22:46</span></span><br><span class="line"><span class="comment"> * \* Description:还是单例模式，在类加载时就已经初始化好对应的实例</span></span><br><span class="line"><span class="comment"> * \</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HungarySingleton</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> HungarySingleton hungarySingleton;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        hungarySingleton = <span class="keyword">new</span> HungarySingleton();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HungarySingleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hungarySingleton;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">HungarySingleton</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 防止序列化时  破坏单例对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Object <span class="title">readResolve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hungarySingleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反射攻击破坏单例模式</p><h4 id="容器单例"><a href="#容器单例" class="headerlink" title="容器单例"></a>容器单例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created By Administrator</span></span><br><span class="line"><span class="comment"> * User: VenusZ</span></span><br><span class="line"><span class="comment"> * Date: on 2019/12/25 22:44</span></span><br><span class="line"><span class="comment"> * Desc: 容器单例模式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ContainerSingleton</span> </span>&#123;</span><br><span class="line"><span class="comment">// 使用map容器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String,Object&gt; singletonMap = <span class="keyword">new</span> HashMap&lt;String,Object&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">putInstance</span><span class="params">(String key,Object instance )</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(StringUtils.isNotBlank(key) &amp;&amp; instance != <span class="keyword">null</span>) <span class="keyword">if</span> (singletonMap.containsKey(key)) &#123;</span><br><span class="line">            singletonMap.put(key, instance);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getInstance</span><span class="params">(String key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> singletonMap.get(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Enum枚举单例"><a href="#Enum枚举单例" class="headerlink" title="Enum枚举单例"></a>Enum枚举单例</h4><p>解决序列化和反序列化，以及反射工具破坏单例模式的隐患。<strong><u>推荐使用枚举单例</u></strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用反编译jad工具查看对应反编译代码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> EnumInstance &#123;</span><br><span class="line">    INSTANCE&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">printLine</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          System.out.println(<span class="string">"print Line"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">printLine</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object data;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setData</span><span class="params">(Object data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li>注意使用时，是否需要线程安全</li><li>注意使用时，是否序列化，会破坏单例模式</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;单例模式介绍&quot;&gt;&lt;a href=&quot;#单例模式介绍&quot; class=&quot;headerlink&quot; title=&quot;单例模式介绍&quot;&gt;&lt;/a&gt;单例模式介绍&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;定义&lt;/strong&gt;：保证一个类仅有一个实例，并提供一个全局访问点。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;类型&lt;/strong&gt;：创建型&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;适用场景&lt;/strong&gt;：想确保任何情况下都绝对只有一个实例。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;优点&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在内存里只有一个实例，减少内存开销；&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;可以避免对资源的多重占用；&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;设置全局访问点，严格控制访问；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;缺点&lt;/strong&gt;：没有借口，不方便扩展&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;重点&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;私有构造器；&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;线程安全；&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;延迟加载；&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;序列化和反序列化安全；&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;反射；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;相关设计模式&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;单例模式和工厂模式；&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;单例模式和享元模式；&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="创建型模式" scheme="/categories/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>markdown 入门语法笔记</title>
    <link href="/2019/12/24/markdown%20%E8%AF%AD%E6%B3%95%E7%AC%94%E8%AE%B0/"/>
    <id>/2019/12/24/markdown 语法笔记/</id>
    <published>2019-12-23T16:00:00.000Z</published>
    <updated>2019-12-24T14:42:02.517Z</updated>
    
    <content type="html"><![CDATA[<h1 id="markdown-入门语法笔记"><a href="#markdown-入门语法笔记" class="headerlink" title="markdown 入门语法笔记"></a>markdown 入门语法笔记</h1><h2 id="1、标题"><a href="#1、标题" class="headerlink" title="## 1、标题"></a>## 1、标题</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">标题 </span><br><span class="line"># 一级标题</span><br><span class="line">## 二级标题</span><br><span class="line">### 三级标题</span><br><span class="line">#### 四级标题</span><br><span class="line">##### 五级标题</span><br></pre></td></tr></table></figure><p>效果</p><h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><a id="more"></a><h2 id="2、区块引用"><a href="#2、区块引用" class="headerlink" title="2、区块引用"></a>2、区块引用</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">区块引用  </span><br><span class="line">    这个单个使用</span><br><span class="line">    &gt; 这是段引用例子    </span><br><span class="line">    </span><br><span class="line">    多个使用</span><br><span class="line">    &gt; 测试加冒号的区块引用 </span><br><span class="line">    &gt;&gt; 测试加冒号的区块引用 </span><br><span class="line">    &gt;&gt;&gt; 测试加冒号的区块引用</span><br></pre></td></tr></table></figure><blockquote><p>这个单个使用</p></blockquote><p>多个使用</p><blockquote><p>测试加冒号的区引用 </p><blockquote><p>测试加冒号的区块引用 </p><blockquote><p>测试加冒号的区块引用 </p></blockquote></blockquote></blockquote><h2 id="3、列表"><a href="#3、列表" class="headerlink" title="3、列表"></a>3、列表</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">无序列表：可以使用星号*、加号+或者时减号-作为列表标记</span><br><span class="line">    例子：</span><br><span class="line">    * 橙子</span><br><span class="line">    * 西瓜</span><br><span class="line">    * 香蕉</span><br><span class="line">    或者</span><br><span class="line">    + 橙子</span><br><span class="line">    + 西瓜</span><br><span class="line">    + 香蕉</span><br><span class="line">    或者</span><br><span class="line">    - 橙子</span><br><span class="line">    - 西瓜</span><br><span class="line">    - 香蕉</span><br><span class="line">有序列表： 数字加英文句点</span><br><span class="line">    例子：</span><br><span class="line">    <span class="number">1</span>. Red</span><br><span class="line">    <span class="number">2</span>. yellow</span><br><span class="line">    <span class="number">3</span>. green</span><br></pre></td></tr></table></figure><p>例子：</p><ul><li>橙子</li><li>西瓜</li><li>香蕉</li></ul><p>例子：</p><ol><li>Red</li><li>yellow</li><li>green</li></ol><h2 id="4、分隔线"><a href="#4、分隔线" class="headerlink" title="4、分隔线"></a>4、分隔线</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">分隔线：在一行中用三个以上的星号、减号、底线来建立一个分隔线</span><br><span class="line">****</span><br><span class="line">___</span><br><span class="line">---</span><br></pre></td></tr></table></figure><hr><hr><hr><h2 id="5、超链接"><a href="#5、超链接" class="headerlink" title="5、超链接"></a>5、超链接</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">超链接：中括号+括号</span><br><span class="line">    [我的博客地址](https:<span class="comment">//venusj.github.io/)</span></span><br></pre></td></tr></table></figure><p><a href="https://venusj.github.io/" target="_blank" rel="noopener">我的博客地址</a></p><h2 id="6、代码块"><a href="#6、代码块" class="headerlink" title="6、代码块"></a>6、代码块</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">代码块语法  三个~ 或者```</span><br><span class="line">​~~~ </span><br><span class="line">```</span><br></pre></td></tr></table></figure><h2 id="7、字体"><a href="#7、字体" class="headerlink" title="7、字体"></a>7、字体</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">加粗： **加粗的字体**</span><br><span class="line">代码高亮： ==高亮的字体==</span><br><span class="line">删除线：~~删除线的字体~~</span><br><span class="line">斜体： *斜体的字体*</span><br></pre></td></tr></table></figure><p>加粗： <strong>加粗的字体</strong><br>代码高亮： == 高亮的字体 == (暂时不知道为啥无效)<br>删除线：<del>删除线的字体</del><br>斜体： <em>斜体的字体</em></p><h2 id="8、图片插入"><a href="#8、图片插入" class="headerlink" title="8、图片插入"></a>8、图片插入</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">本地图片 语法：感叹号+中括号+圆括号   </span><br><span class="line">![图片](图片地址)   ![头像](/<span class="number">01</span>.jpg)</span><br><span class="line">在线图片</span><br></pre></td></tr></table></figure><p>本地图片   <img src="/2019/12/24/markdown 语法笔记/01.jpg" alt="头像"><br>在线图片 </p><p><img src="https://dss0.baidu.com/73t1bjeh1BF3odCf/it/u=1817457932,3341712964&amp;fm=85&amp;s=0941814603F1BBC054C31903030090DA" alt="在线图片"></p><h2 id="9、表格"><a href="#9、表格" class="headerlink" title="9、表格"></a>9、表格</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用工具快捷键 本人使用的工具是：Typora   创建表格快捷键是ctrl + T</span><br></pre></td></tr></table></figure><table><thead><tr><th>名称</th><th>性别</th><th>年龄</th></tr></thead><tbody><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td></tr></tbody></table><h2 id="10-、快捷键整理"><a href="#10-、快捷键整理" class="headerlink" title="10 、快捷键整理"></a>10 、快捷键整理</h2><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ctrl + shift + <span class="number">1</span>  显示目录</span><br><span class="line">ctrl + [          列表缩一格</span><br><span class="line">ctrl + ]          列表进一格</span><br><span class="line">ctrl + shift + [  有序列表 </span><br><span class="line">ctrl + shift + ]  无序列表 </span><br><span class="line">ctrl + shift + <span class="type">Q</span>  区块引用</span><br><span class="line">ctrl + <span class="number">1</span> 到 <span class="number">6</span>     标题</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;markdown-入门语法笔记&quot;&gt;&lt;a href=&quot;#markdown-入门语法笔记&quot; class=&quot;headerlink&quot; title=&quot;markdown 入门语法笔记&quot;&gt;&lt;/a&gt;markdown 入门语法笔记&lt;/h1&gt;&lt;h2 id=&quot;1、标题&quot;&gt;&lt;a href=&quot;#1、标题&quot; class=&quot;headerlink&quot; title=&quot;## 1、标题&quot;&gt;&lt;/a&gt;## 1、标题&lt;/h2&gt;&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;标题 &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# 一级标题&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;## 二级标题&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;### 三级标题&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#### 四级标题&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;##### 五级标题&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;效果&lt;/p&gt;
&lt;h1 id=&quot;一级标题&quot;&gt;&lt;a href=&quot;#一级标题&quot; class=&quot;headerlink&quot; title=&quot;一级标题&quot;&gt;&lt;/a&gt;一级标题&lt;/h1&gt;&lt;h2 id=&quot;二级标题&quot;&gt;&lt;a href=&quot;#二级标题&quot; class=&quot;headerlink&quot; title=&quot;二级标题&quot;&gt;&lt;/a&gt;二级标题&lt;/h2&gt;&lt;h3 id=&quot;三级标题&quot;&gt;&lt;a href=&quot;#三级标题&quot; class=&quot;headerlink&quot; title=&quot;三级标题&quot;&gt;&lt;/a&gt;三级标题&lt;/h3&gt;&lt;h4 id=&quot;四级标题&quot;&gt;&lt;a href=&quot;#四级标题&quot; class=&quot;headerlink&quot; title=&quot;四级标题&quot;&gt;&lt;/a&gt;四级标题&lt;/h4&gt;&lt;h5 id=&quot;五级标题&quot;&gt;&lt;a href=&quot;#五级标题&quot; class=&quot;headerlink&quot; title=&quot;五级标题&quot;&gt;&lt;/a&gt;五级标题&lt;/h5&gt;
    
    </summary>
    
      <category term="学习" scheme="/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="markdown" scheme="/tags/markdown/"/>
    
  </entry>
  
  <entry>
    <title>设计模式</title>
    <link href="/2019/12/24/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>/2019/12/24/设计模式/设计模式/</id>
    <published>2019-12-23T16:00:00.000Z</published>
    <updated>2019-12-25T15:05:18.917Z</updated>
    
    <content type="html"><![CDATA[<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><p>在编码过程中需要结合实际的业务场景、业务模型进行对应的模式设计，但也不能过分遵守设计原则和使用设计模式，需要把握两者之间的平衡。</p><a id="more"></a><ul><li><strong>创建型模式</strong><ul><li>工厂方法模式</li><li>抽象工厂模式</li><li>建造者模式</li><li>单例模式</li><li>原型模式</li></ul></li><li><strong>结构型模式</strong><ul><li>适配器模式</li><li>装饰者模式</li><li>代理模式</li><li>外观模式</li><li>桥接模式</li><li>组合模式</li><li>享元模式</li></ul></li><li><strong>行为型模式</strong><ul><li>策略模式</li><li>观察者模式</li><li>责任链模式</li><li>备忘录模式</li><li>模板方法模式</li><li>迭代器模式</li><li>中介者模式</li><li>命令模式</li><li>访问者模式</li><li>解释器模式</li><li>状态模式</li></ul></li></ul><h2 id="七大原则"><a href="#七大原则" class="headerlink" title="七大原则"></a>七大原则</h2><ul><li><p><strong>开闭原则</strong></p><p>定义：一个软件实体如：类、模块和函数应该对扩展开放，对修改关闭。</p><p>用抽象构建框架，用实现扩展细节</p><p>优点：提高软件系统的可服用性及可维护性</p></li><li><p><strong>依赖倒置原则</strong></p><p>定义：高层模块不应该依赖低层模块，二者都应该依赖其抽象。</p><p>抽象不应该依赖细节；细节应该依赖抽象，针对接口编程，不要针对实现编程。</p></li><li><p><strong>单一职责原则</strong></p></li><li><p><strong>接口隔离原则</strong></p></li><li><p><strong>迪米特法则(最少知道原则)</strong></p></li><li><p><strong>里氏替换原则</strong></p></li><li><p><strong>合成/服用原则</strong></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;设计模式&quot;&gt;&lt;a href=&quot;#设计模式&quot; class=&quot;headerlink&quot; title=&quot;设计模式&quot;&gt;&lt;/a&gt;设计模式&lt;/h1&gt;&lt;p&gt;在编码过程中需要结合实际的业务场景、业务模型进行对应的模式设计，但也不能过分遵守设计原则和使用设计模式，需要把握两者之间的平衡。&lt;/p&gt;
    
    </summary>
    
      <category term="设计模式" scheme="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>初识Scala</title>
    <link href="/2019/01/10/Scala%E5%AD%A6%E4%B9%A0/"/>
    <id>/2019/01/10/Scala学习/</id>
    <published>2019-01-09T16:00:00.000Z</published>
    <updated>2019-12-24T14:33:47.201Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Scala面向对象"><a href="#Scala面向对象" class="headerlink" title="Scala面向对象"></a>Scala面向对象</h2><ul><li><p>面向对象概述</p></li><li><p>类的定义与使用</p></li><li><p>构造器</p></li><li><p>继承与重写</p></li><li><p>抽象类</p></li><li><p>伴生类和伴生对象</p></li><li><p>apply、case class 、trait</p><a id="more"></a><h3 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h3><p>封装：属性、方法封装到类中</p><p>继承：父类和子类之间的关系</p><p>多态：<strong>父类引用指向子类对象</strong></p><h3 id="类的定义与使用"><a href="#类的定义与使用" class="headerlink" title="类的定义与使用"></a>类的定义与使用</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">SimpleObject</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> people = <span class="keyword">new</span> <span class="type">People</span>()</span><br><span class="line">    people.name = <span class="string">"Tony"</span></span><br><span class="line">    println(people.name + <span class="string">"...."</span> + people.age)</span><br><span class="line"></span><br><span class="line">    println(people.eat)</span><br><span class="line"></span><br><span class="line">    people.sign(<span class="string">"english"</span>)</span><br><span class="line"></span><br><span class="line">    people.printSex()</span><br><span class="line"><span class="comment">//    println(people.sex)    错误示例</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">  <span class="comment">//var 定义一个变量，已存在set/get方法</span></span><br><span class="line">  <span class="keyword">var</span> name:<span class="type">String</span> = <span class="string">""</span></span><br><span class="line">  <span class="comment">//val 定义一个常量，需要初始值，只有get方法</span></span><br><span class="line">  <span class="keyword">val</span> age:<span class="type">Int</span> = <span class="number">10</span></span><br><span class="line">  <span class="comment">//private [this] 修饰的属性只能在类里面进行访问</span></span><br><span class="line">  <span class="keyword">private</span> [<span class="keyword">this</span>] <span class="keyword">val</span> sex:<span class="type">String</span> = <span class="string">"woman"</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">printSex</span></span>(): <span class="type">Unit</span> = &#123;</span><br><span class="line">    println(<span class="string">"people sex: "</span> + sex)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">eat</span></span>():<span class="type">String</span> = &#123;</span><br><span class="line">    name + <span class="string">"eatting......."</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">sign</span></span>(language:<span class="type">String</span>):<span class="type">Unit</span> = &#123;</span><br><span class="line">    println(name + <span class="string">"is go back home sign to "</span> + language )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ConstructorApp</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> user = <span class="keyword">new</span> <span class="type">User</span>(<span class="string">"Tony"</span>, <span class="number">22</span>)</span><br><span class="line">    println(user.name + <span class="string">":"</span> + user.age + <span class="string">":"</span> + user.address)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> user2 = <span class="keyword">new</span> <span class="type">User</span>(<span class="string">"Sam"</span>, <span class="number">25</span>,<span class="string">"man"</span>)</span><br><span class="line">    println(user2.name + <span class="string">":"</span> + user2.age + <span class="string">":"</span> + user2.address + <span class="string">":"</span> + user2.gender)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//主构造器 跟在class后面的为主构造器</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span>(<span class="params">val name:<span class="type">String</span>, val age:<span class="type">Int</span></span>) </span>&#123;</span><br><span class="line">  println(<span class="string">"User构造函数开始。。。"</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> address = <span class="string">"深圳"</span></span><br><span class="line">  <span class="keyword">var</span> gender:<span class="type">String</span> = _</span><br><span class="line"></span><br><span class="line">  <span class="comment">//附属构造器 可多个</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">this</span></span>(name:<span class="type">String</span>, age:<span class="type">Int</span>, gender:<span class="type">String</span>)&#123;</span><br><span class="line">    <span class="comment">//附属构造器第一行代码必须要调用主构造器或者其他附属构造器</span></span><br><span class="line">    <span class="keyword">this</span>(name,age)</span><br><span class="line">    <span class="keyword">this</span>.gender = gender</span><br><span class="line">  &#125;</span><br><span class="line">  println(<span class="string">"User构造函数结束。。。"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="继承与重写"><a href="#继承与重写" class="headerlink" title="继承与重写"></a>继承与重写</h3><p><strong>继承</strong>：子类特有的属性一定在主构造方法使用var关键字修饰，否则在外部访问不了(如下面代码中的major属性)。在实例子类时一定会先调用父类的构造函数，在调用自己的构造函数(如下运行结果所示)。</p><p><strong>重写</strong>：如果子类需要使用父类中的属性或者方法是一定需要使用override关键字修饰。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ConstructorApp</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> student = <span class="keyword">new</span> <span class="type">Student</span>(<span class="string">"Tony"</span>,<span class="number">23</span>,<span class="string">"English"</span>)</span><br><span class="line">    println(student.name +<span class="string">":"</span> + student.major)</span><br><span class="line">    println(student)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>(<span class="params">name:<span class="type">String</span>, age:<span class="type">Int</span>, var major:<span class="type">String</span></span>) <span class="keyword">extends</span> <span class="title">User</span>(<span class="params">name:<span class="type">String</span>, age:<span class="type">Int</span></span>) </span>&#123;</span><br><span class="line">  println(<span class="string">"Student构造函数开始。。。"</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="keyword">val</span> address: <span class="type">String</span> = <span class="string">"上海"</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//默认是调用Object的toString方法</span></span><br><span class="line">  <span class="comment">//override def toString: String = super.toString</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">toString</span></span>: <span class="type">String</span> = <span class="string">"Student重写toString方法。重写address："</span> + address</span><br><span class="line"></span><br><span class="line">  println(<span class="string">"Student构造函数结束。。。"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">User构造函数开始。。。</span><br><span class="line">User构造函数结束。。。</span><br><span class="line">Student构造函数开始。。。</span><br><span class="line">Student构造函数结束。。。</span><br><span class="line">Tony:English</span><br><span class="line">Student重写toString方法。重写address：上海</span><br></pre></td></tr></table></figure><h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p>类的一个或者多个方法没有完成的实现(只有定义，没有实现)</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">AbstractApp</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> dog = <span class="keyword">new</span> <span class="type">Dog</span>()</span><br><span class="line">    println(<span class="string">"name: "</span> + dog.name + <span class="string">" age: "</span> + dog.age)</span><br><span class="line">    dog.speak</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">speak</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">  <span class="title">val</span> <span class="title">name</span></span>:<span class="type">String</span></span><br><span class="line">  <span class="keyword">val</span> age:<span class="type">Int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">speak</span></span>: <span class="type">Unit</span> = &#123;</span><br><span class="line">    println(<span class="string">"wang wang wang!!!"</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="keyword">val</span> name: <span class="type">String</span> = <span class="string">"旺财"</span></span><br><span class="line">  <span class="keyword">override</span> <span class="keyword">val</span> age: <span class="type">Int</span> = <span class="number">3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="伴生类和伴生对象"><a href="#伴生类和伴生对象" class="headerlink" title="伴生类和伴生对象"></a>伴生类和伴生对象</h3><p>如果有一个class,还有一个与class同名的object。那么这个object就是class的伴生对象，class就是这个object的伴生类。</p><h3 id="apply、case-class-、trait"><a href="#apply、case-class-、trait" class="headerlink" title="apply、case class 、trait"></a>apply、case class 、trait</h3><p><strong>apply</strong>：下面代码中class ApplyTest和object ApplyTest为伴生类和伴生对象。</p><p>当在伴生类和伴生对象中都定义一个apply方法时，如果</p><p>使用类名() ==&gt; Object.apply，调用object中的apply方法;</p><p>使用对象() ==&gt; Class.apply，调用class中的apply方法;</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ApplyApp</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">for</span> (i &lt;- <span class="number">1</span> to <span class="number">10</span>) &#123;</span><br><span class="line">      <span class="type">ApplyTest</span>.add</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    println(<span class="type">ApplyTest</span>.count)   <span class="comment">// 结果为10  表明object本身就是个单例对象</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//类名</span></span><br><span class="line">    <span class="keyword">val</span> a = <span class="type">ApplyTest</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> b = <span class="keyword">new</span> <span class="type">ApplyTest</span>()</span><br><span class="line">    println(b)</span><br><span class="line">    <span class="comment">//对象名()   对象为实例出来的b</span></span><br><span class="line">    b()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ApplyTest</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(): <span class="type">Unit</span> =&#123;</span><br><span class="line">    println(<span class="string">"Class ApplyTest 的apply()方法"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ApplyTest</span></span>&#123;</span><br><span class="line">  println(<span class="string">"Object ApplyTest 开始"</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">add</span> </span>= &#123;</span><br><span class="line">    count = count + <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//最佳实践：在Object的apply方法中去new Class</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(): <span class="type">ApplyTest</span> =&#123;</span><br><span class="line">    println(<span class="string">"Object ApplyTest 的apply()方法"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在object中apply中new class</span></span><br><span class="line">    <span class="keyword">new</span> <span class="type">ApplyTest</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  println(<span class="string">"Object ApplyTest 结束"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Object ApplyTest 开始</span><br><span class="line">Object ApplyTest 结束</span><br><span class="line">10</span><br><span class="line">Object ApplyTest 的apply()方法</span><br><span class="line">com.venusj.scala.course04.ApplyTest@7cf10a6f</span><br><span class="line">Class ApplyTest 的apply()方法</span><br></pre></td></tr></table></figure><p><strong>case class</strong>：通常用在模式匹配中，case class 不需要new。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">CaseClassApp</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    println(<span class="type">Cat</span>(<span class="string">"小猫咪"</span>).name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span>(<span class="params">name:<span class="type">String</span></span>)</span></span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">小猫咪</span><br></pre></td></tr></table></figure><p><strong>trait</strong>：这个关键字可以理解成java中的interface。只有定义，没有实现。假如一个类只实现一个被trait修饰的类，可以使用extends,若实现多个被trait修饰的类，第一个使用extends,后面的都使用with关键字。</p><p>源码示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class SparkConf(loadDefaults: Boolean) </span><br><span class="line">extends Cloneable </span><br><span class="line">with Logging </span><br><span class="line">with Serializable</span><br></pre></td></tr></table></figure><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> scala</span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Cloneable</span> <span class="keyword">extends</span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">Object</span> <span class="keyword">with</span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Logging</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> scala</span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Serializable</span> <span class="keyword">extends</span> <span class="title">scala</span>.<span class="title">Any</span> <span class="keyword">with</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Scala面向对象&quot;&gt;&lt;a href=&quot;#Scala面向对象&quot; class=&quot;headerlink&quot; title=&quot;Scala面向对象&quot;&gt;&lt;/a&gt;Scala面向对象&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;面向对象概述&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;类的定义与使用&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;构造器&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;继承与重写&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;抽象类&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;伴生类和伴生对象&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;apply、case class 、trait&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Scala" scheme="/tags/Scala/"/>
    
  </entry>
  
  <entry>
    <title>Git学习</title>
    <link href="/2018/12/29/Git%E5%AD%A6%E4%B9%A0/"/>
    <id>/2018/12/29/Git学习/</id>
    <published>2018-12-28T16:00:00.000Z</published>
    <updated>2019-12-24T14:42:40.541Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Git本地提交图示："><a href="#Git本地提交图示：" class="headerlink" title="Git本地提交图示："></a>Git本地提交图示：</h3><p><img src="/2018/12/29/Git学习/Git本地提交流程图.png" alt></p><h3 id="Git基础命令"><a href="#Git基础命令" class="headerlink" title="Git基础命令"></a>Git基础命令</h3><ul><li><p>git status        –查看工作区、暂存区状态</p></li><li><p>git add <files>                  –将工作区中”新增或修改的文件”增加到暂存区</files></p></li><li><p>git commit -m “***” &lt;<files>&gt;      –将文件冲暂存区提交到本地仓库,并且增加提交注释就是<-m>后面的内容</-m></files></p></li><li><p>git log –pretty=oneline                    –查看提交日志，后面参数是每个提交日志只显示一行</p><ul><li>Tips: 数据太多显示时，空格键向下翻页、b键向上翻页，q键退出</li><li>git log –oneline                         –简介模式的git log</li></ul></li><li><p>git reflog                                  –显示提交记录，并且显示HEAD步数，对于回滚帮助作用很大</p><ul><li>Tips: HEAD@{移动到当前需要多少步}<a id="more"></a></li></ul></li><li><p>版本前进后退：</p><ul><li><p>git reset –hard &lt;部分索引值&gt;     –基于索引值操作(推荐使用)</p></li><li><p>git reset –hard HEAD^                –使用^符号：只能后退，根据当前版本，退一步。</p></li><li><p>git reset –hard HEAD^^               –根据当前版本，只能后退退两步，^的数量表示后退多少步。</p></li><li><p>git reset –hard HEAD~n              –使用~符号,是为了简化^符号过多的情况，~后面的n代表当前版本后退多少步</p></li></ul></li><li><p>reset命令的是三个参数对比</p><ul><li>–soft: 仅仅在本地库移动HEAD指针(只有本地库进行了回退)</li><li>–mixed: 在本地库移动HEAD指针，重置暂存区(工作区、暂存区回退)</li><li>–hard: 在本地库移动HEAD指针，重置暂存区，重置工作区(工作区、暂存区、本地库同时回退)</li></ul></li><li>删除文件并找回：<ul><li>前提：删除前，文件存在是的状态提交到了本地库</li><li>操作：git reset –hard &lt;指针位置&gt;  </li></ul></li><li>文件比较：<ul><li>git diff <files>          – 比较文件差异 ,将工作区中的文件和暂存区进行比较，还未add时的比较</files></li><li>git diff [本地库中的历史版本] <files>     –将工作区中的文件和本地库历史记录进行比较<ul><li>:set nu命令可以在VIM编辑器中显示行号。</li><li>tail -n 3 files   该命令用于查看文件倒数三行信息</li></ul></files></li></ul></li><li><p>Git分支 </p><ul><li>好处：同时并行推进多个功能开发，提高开发效率；哥哥分支在开发过程中，如果某一个分支开发失败，不会影响到主干代码；删除失败分支重新开始就行。 </li><li>git branch -v                           – 查看当前所有分支，-v参数表示版本号，可带可不带</li><li>git branch dev                        –创建名为dev的分支</li><li>git checkout dev                    –切换到分支dev上</li><li>合并分支：<ul><li>场景：假设在dev分支进行修复Bug,然后要把dev分支最新代码合并到master上</li><li>第一步先切换到master分支上，</li><li>第二步执行git merge dev 命令</li></ul></li><li>冲突解决： <ul><li>场景：假设master分支和dev分支同事修改一个文件的同一地方代码，并且都提交到本地库，这个时候合并执行git merge dev就会显示文件冲突。</li><li>第一步找到对应文件冲突地方，并且修正，此时还是处于Merging状态，</li><li>第二步需要对应修改冲突后的文件进行git add <files> 操作，</files></li><li>第三步执行git commit命令，这个提交命令<strong>一定</strong>不能指定某个文件。这样Merging状态就会消失，同时分支已经合并好了。</li></ul></li><li>git remote -v                                  查看所有别名命令 </li><li>git remote  add origin git_url                       为当前链接取一个origin别名</li><li>git push [别名]  [分支]                                      把本地仓库修改推送到远程库</li><li>git clone git_url</li><li>拉取<ol><li>无冲突时： <ul><li>pull = fetch + merge</li><li>git fetch [远程库地址别名] [远程分支名]            先拉取代码下来，文件未合并</li><li>git merge [远程地址别名/远程分支名]            合并拉取下来的代码</li><li>git pull [远程库地址别名] [远程分支名]</li></ul></li><li>有冲突时：<ul><li>场景：自己在本地库中修改完代码，之后push到远程库时，如果不是基于远程库的最新版所做的改变，不能推送，必须先pull。<ul><li>拉取下来后如果最新代码与自己的有冲突，则按照如下步骤操作(即上面的冲突解决操作)</li></ul></li></ul></li></ol></li><li><p>跨团队协作：</p><ul><li>git fork git_url</li></ul></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Git本地提交图示：&quot;&gt;&lt;a href=&quot;#Git本地提交图示：&quot; class=&quot;headerlink&quot; title=&quot;Git本地提交图示：&quot;&gt;&lt;/a&gt;Git本地提交图示：&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;/2018/12/29/Git学习/Git本地提交流程图.png&quot; alt&gt;&lt;/p&gt;
&lt;h3 id=&quot;Git基础命令&quot;&gt;&lt;a href=&quot;#Git基础命令&quot; class=&quot;headerlink&quot; title=&quot;Git基础命令&quot;&gt;&lt;/a&gt;Git基础命令&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;git status        –查看工作区、暂存区状态&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;git add &lt;files&gt;                  –将工作区中”新增或修改的文件”增加到暂存区&lt;/files&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;git commit -m “***” &amp;lt;&lt;files&gt;&amp;gt;      –将文件冲暂存区提交到本地仓库,并且增加提交注释就是&lt;-m&gt;后面的内容&lt;/-m&gt;&lt;/files&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;git log –pretty=oneline                    –查看提交日志，后面参数是每个提交日志只显示一行&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Tips: 数据太多显示时，空格键向下翻页、b键向上翻页，q键退出&lt;/li&gt;
&lt;li&gt;git log –oneline                         –简介模式的git log&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;git reflog                                  –显示提交记录，并且显示HEAD步数，对于回滚帮助作用很大&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Tips: HEAD@{移动到当前需要多少步}&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
      <category term="学习" scheme="/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Git" scheme="/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="/2018/08/18/hello-world/"/>
    <id>/2018/08/18/hello-world/</id>
    <published>2018-08-18T14:50:33.742Z</published>
    <updated>2018-08-18T14:50:33.742Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
</feed>
